<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python数据分析判断题整理 | CYN's Blog</title><meta name="author" content="Yinuo Chen"><meta name="copyright" content="Yinuo Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="Python数据分析判断题整理">
<meta property="og:url" content="https://cccignore.github.io/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A4%E6%96%AD%E9%A2%98%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="CYN&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.huizhanii.com/wp-content/uploads/2023/10/202310040719411.jpg">
<meta property="article:published_time" content="2025-06-20T15:43:27.000Z">
<meta property="article:modified_time" content="2025-06-20T15:43:27.000Z">
<meta property="article:author" content="Yinuo Chen">
<meta property="article:tag" content="考试复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.huizhanii.com/wp-content/uploads/2023/10/202310040719411.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python数据分析判断题整理",
  "url": "https://cccignore.github.io/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A4%E6%96%AD%E9%A2%98%E6%95%B4%E7%90%86/",
  "image": "https://www.huizhanii.com/wp-content/uploads/2023/10/202310040719411.jpg",
  "datePublished": "2025-06-20T15:43:27.000Z",
  "dateModified": "2025-06-20T15:43:27.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yinuo Chen",
      "url": "https://cccignore.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://cccignore.github.io/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A4%E6%96%AD%E9%A2%98%E6%95%B4%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python数据分析判断题整理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/fill-left.css"><script src="/live2d-widget/dist/autoload.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/img/my-background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/img/loading.gif" data-lazy-src="/img/my-avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://www.huizhanii.com/wp-content/uploads/2023/10/202310040719411.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "/img/loading.gif" data-lazy-src="/img/logo.png" alt="Logo"><span class="site-name">CYN's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Python数据分析判断题整理</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python数据分析判断题整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-20T15:43:27.000Z" title="发表于 2025-06-20 23:43:27">2025-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-20T15:43:27.000Z" title="更新于 2025-06-20 23:43:27">2025-06-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">Python数据分析</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E5%88%A4%E6%96%AD%E9%A2%98/">判断题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="waline-pageview-count" data-path="/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A4%E6%96%AD%E9%A2%98%E6%95%B4%E7%90%86/"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A4%E6%96%AD%E9%A2%98%E6%95%B4%E7%90%86/#post-comment"><span class="waline-comment-count" data-path="/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A4%E6%96%AD%E9%A2%98%E6%95%B4%E7%90%86/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><!-- 文章摘要，会显示在首页 -->
<span id="more"></span>

<h2 id="第二章：Python语言基础与环境-第三章：Pandas-数据结构与操作"><a href="#第二章：Python语言基础与环境-第三章：Pandas-数据结构与操作" class="headerlink" title="第二章：Python语言基础与环境 + 第三章：Pandas 数据结构与操作"></a>第二章：Python语言基础与环境 + 第三章：Pandas 数据结构与操作</h2><p><strong>1. 元组中的元素只能是同一数据类型 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** Python 的元组和列表都可以包含不同数据类型的元素，是异构容器。例如 `(1, "hello", 3.14)` 是合法的。
</details>

<hr>
<p><strong>2. 可以用<code>a=&#123;&#125;</code>创建空的集合 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 使用 `{}` 创建的是一个空的<b>字典</b>。要创建空集合，必须使用 `set()` 构造函数。
</details>

<hr>
<p><strong>3. 在Python中，运行代码<code>&#39;5&#39;+5</code>，会生成字符串’55’（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 字符串和整数之间不能直接使用 `+` 运算符，会引发 `TypeError`。
</details>

<hr>
<p><strong>4. 语句<code>20==20.0</code>返回结果是True （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `==` 运算符比较的是值。整数 `20` 和浮点数 `20.0` 的数值相等。
</details>

<hr>
<p><strong>5. 可以将列表作为字典的键 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 字典的键必须是不可变（hashable）的对象。列表是可变的，因此不能作为键。
</details>

<hr>
<p><strong>6. 所有写在“&#x2F;&#x2F;”号之后的文本会自动被Python解释器忽略 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** Python 的单行注释符号是 `#`。`//` 是整除运算符。
</details>

<hr>
<p><strong>7. 列表中的pop方法可以返回特定位置的元素但是remove不可以（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `.pop(index)` 会移除并返回指定索引的元素。`.remove(value)` 移除指定值，但返回 `None`。
</details>

<hr>
<p><strong>8. 通过<code>isinstance(a, (int, str))</code>可以检测变量a的类型是否在int, str中 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 `isinstance` 函数的标准用法，其第二个参数可以是一个类型元组。
</details>

<hr>
<p><strong>9. 列表、字典、Numpy数组都是可变(mutable)对象 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这三者都允许在创建后修改其内部的元素或内容。
</details>

<hr>
<p><strong>10. <code>tup=(1,[1,2,3],3); tup[1].append(4)</code>不能执行（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 元组本身是不可变的，但其内部的可变元素（如列表）是可以被修改的。
</details>

<hr>
<p><strong>11. <code>&#39;5&#39;+&#39;3&#39;</code>的结果是’8’（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 字符串使用 `+` 运算符会进行拼接，结果是字符串 `'53'`。
</details>

<hr>
<p><strong>12. 对于对象<code>a=[1,2,3]</code>和<code>b=[1,2,3]</code>，<code>a is b</code>和<code>a==b</code>输出的结果都为True （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `a == b` (值相等) 是 `True`，但 `a is b` (身份标识不同) 是 `False`，因为它们是两个独立的对象。
</details>

<hr>
<p><strong>13. <code>d=&#123;&#125;; d[tuple([1, 2, 3])] = 5</code>语句不能执行（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 元组是不可变的，可以作为字典的键，该语句合法。
</details>

<hr>
<p><strong>14. 函数柯里化的过程中，如果传入的参数数量不足，剩下的参数将默认为空值传入（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 它会返回一个等待接收剩余参数的新函数。
</details>

<hr>
<p><strong>15. 运行以下代码，<code>4 &gt; 3 &gt; 2 &gt; 1</code>，将返回True（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** Python 支持链式比较，该表达式等价于 `(4 > 3) and (3 > 2) and (2 > 1)`。
</details>

<hr>
<p><strong>16. 下列这句代码是对的：<code>test_data = 1,</code> （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 结尾的逗号会使 Python 将其解释为一个单元素元组 `(1,)`。
</details>

<hr>
<p><strong>17. Python中不可以使用java中表示语句块的“{}”，以及分隔符“；” （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** Python 不使用 `{}` 表示语句块，但可以使用分号 `;` 在同一行分隔多个语句。
</details>

<hr>
<p><strong>18. <code>(4,None,&#39;foo&#39;)+(6,0)+(&#39;bar&#39;)</code>不能执行 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `('bar')` 只是一个带括号的字符串，不是元组。元组和字符串不能相加，会引发 `TypeError`。正确的单元素元组应写为 `('bar',)`。
</details>

<hr>
<p><strong>19. 设<code>a = ’python’</code>,可以执行<code>a[0]=‘P’</code> ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 字符串是不可变对象，不能通过索引赋值来修改内容。
</details>

<hr>
<p><strong>20. <code>None</code>是<code>NoneType</code>类型的唯一实例 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 `None` 的正确定义。
</details>

<hr>
<p><strong>21. 像Java语言一样，Python语句也是以分号结尾的 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** Python 语句以换行符作为默认的终止符。
</details>

<hr>
<p><strong>22. 对于含有换行的多行字符串，可以使用三个单引号’’’或者三个双引号””” （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 Python 定义多行字符串的标准语法。
</details>

<hr>
<p><strong>23. 表达式<code>“[3] in [1, 2, 3, 4]”</code>的值是True.（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `in` 运算符检查的是元素。列表 `[1, 2, 3, 4]` 包含整数 `3`，但不包含列表 `[3]`。
</details>

<hr>
<p><strong>24. <code>def choise(x,y,z=5): choise(5,z= 2,y = 3)</code> 可以调用 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `5` 作为位置参数赋给了 `x`，`y=3` 和 `z=2` 作为关键字参数赋值。所有参数都得到了明确且无冲突的赋值。
</details>

<hr>
<p><strong>25. <code>num1=num2=num3=20</code> 在内存中指向不同的变量地址（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 链式赋值使 `num1`, `num2`, `num3` 都指向内存中同一个存放整数 `20` 的对象。
</details>

<hr>
<p><strong>26. 使用<code>pop( )</code>方法删除列表中某一元素后，该元素从栈顶被推出且无法再访问。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `pop()` 方法会<b>返回</b>被删除的那个元素，可以将其赋值给变量以备后续使用。
</details>

<hr>
<p><strong>27. 在Python中可以使用 id 作为变量名 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `id` 是一个内置函数，但不是关键字。因此可以作为变量名，但这会覆盖内置函数，是不推荐的做法。
</details>

<hr>
<p><strong>28. 列表的插入函数<code>insert()</code>指定的序号可以大于数组长度。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 如果 `index` 大于列表长度，`insert()` 会将元素插入到列表的末尾，效果等同于 `append()`。
</details>

<hr>
<p><strong>29. List中的<code>remove()</code>函数会移除列表中指定的所有的元素。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `.remove(value)` 只会移除列表中<b>第一个</b>匹配到的 `value`。
</details>

<hr>
<p><strong>30. 用 <code>sort</code> 函数可以产生一个排好序的序列副本。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 列表的 `.sort()` **方法**是原地排序，返回 `None`。而内置的 `sorted()` **函数**才会产生一个排好序的副本。
</details>

<hr>
<p><strong>31. <code>tup1=(1,2,3,4,5)；a , b , *rest = tup1；type(rest)</code>；结果为 <code>tuple</code> 。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 在解包赋值中，带星号的 `*rest` 会将所有剩余的元素打包成一个<b>列表 (list)</b>。
</details>

<hr>
<p><strong>32. <code>set([2,[2,3,4]])</code>的输出结果是<code>&#123;2,[2,3,4]&#125;</code>。 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 集合的元素必须是可哈希的。列表 `[2,3,4]` 是可变的，不能放入集合中，会引发 `TypeError`。
</details>

<hr>
<p><strong>33. <code>type((1))</code>和<code>type(())</code>的输出都是<code>tuple</code> （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `type(())` 是 `tuple`，但 `(1)` 只是一个带括号的整数，`type((1))` 是 `int`。
</details>

<hr>
<p><strong>34. 已经<code>a=[1,2,3,4,5]</code>, <code>b=[6,7,8,9]</code>,则<code>a.append(b)</code>的输出结果是<code>[1,2,3,4,5,6,7,8,9]</code> ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `.append(b)` 会将整个列表 `b` 作为一个<b>单一元素</b>添加到 `a` 的末尾，结果是 `[1,2,3,4,5, [6,7,8,9]]`。应使用 `.extend(b)` 或 `a + b` 来拼接。
</details>

<h2 id="第四章：NumPy-数组与操作"><a href="#第四章：NumPy-数组与操作" class="headerlink" title="第四章：NumPy 数组与操作"></a>第四章：NumPy 数组与操作</h2><p><strong>1. <code>ndarray</code>包含的每一个元素均为相同类型。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 NumPy 数组（`ndarray`）的核心特性之一。它是一个同构数据容器，所有元素必须是相同的数据类型（如 `int64`, `float64` 等），这使得 NumPy 能够进行高效的批量运算。（旧版专门测试过是可以异构，但新版已经只能同构。所以答案是T）
</details>

<hr>
<p><strong>2. <code>import numpy as np, arr=np.arange(10), arr.astype(float), print(arr)</code>，输出结果为<code>[0 1 2 3 4 5 6 7 8 9]</code>。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `arr.astype(float)` 方法会返回一个<b>新的</b>、数据类型为浮点数的数组副本，它并<b>不会原地修改</b> `arr` 本身。因此，`print(arr)` 打印的仍然是原始的整数数组。
</details>

<hr>
<p><strong>3. 嵌套序列能被转换为多维数组（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `np.array()` 函数可以将嵌套的列表或元组（如 `[[1,2],[3,4]]`）转换为多维 NumPy 数组。
</details>

<hr>
<p><strong>4. NumPy中的<code>random</code>函数中的<code>randn()</code>可以产生N(0,1)的数（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `np.random.randn()` 函数用于生成服从标准正态分布（均值为0，方差为1，即 N(0,1)）的随机数。
</details>

<hr>
<p><strong>5. 使用<code>np.unique</code>函数可以对NumPy数组进行去重。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `np.unique(arr)` 会找出数组 `arr` 中的唯一元素，并返回一个已排序的新数组。
</details>

<hr>
<p><strong>6. 两个大小相等数组之间的算术运算，都是“点对点”的运算。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 NumPy 的核心特性，也称为元素级 (element-wise) 运算。数组间的算术运算会作用于对应位置的元素。
</details>

<hr>
<p><strong>7. 可以通过numpy中的<code>astype</code>方法显式地转换数组的数据类型。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `arr.astype(new_dtype)` 是转换 NumPy 数组数据类型的标准方法。
</details>

<hr>
<p><strong>8. <code>np.arange()</code>是python内建函数的<code>range</code>的数组版（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `np.arange()` 的功能与 `range()` 类似，但它返回的是一个 NumPy 数组，而不是一个迭代器，并且它支持浮点数步长。
</details>

<hr>
<p><strong>9. <code>arr.mean(1)</code>计算的是每一列的平均值，<code>arr.sum(0)</code>计算行轴向的累和（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** <ul><li>`axis=1` 表示沿着<b>行</b>的方向进行计算，因此 `arr.mean(1)` 计算的是每一<b>行</b>的平均值。</li><li>`axis=0` 表示沿着<b>列</b>的方向进行计算，因此 `arr.sum(0)` 计算的是每一<b>列</b>的和。</li></ul>
</details>

<hr>
<p><strong>10. 数组的切片就是将原数组的数据复制，对切片的修改不会影响原数组（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** NumPy 数组的切片返回的是原始数组的<b>视图 (view)</b>，而不是副本。对切片（视图）的修改会直接影响到原始数组。
</details>

<hr>
<p><strong>11. 数组生成函数<code>array</code>将输入数据转化为<code>ndarray</code>，默认复制所有的输入数据.（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `np.array()` 函数默认会创建一个输入数据的副本，除非输入本身就是一个 `ndarray` 且 `copy=False`。
</details>

<hr>
<p><strong>12. 运用<code>arr.ndim</code>可以查看数组<code>arr</code>的秩。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `.ndim` 属性返回数组的维度数，即秩 (rank)。
</details>

<hr>
<p><strong>13. 同尺寸数组之间直接的比较会产生一个布尔值。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 数组间的比较是元素级的，会产生一个与原数组形状相同的<b>布尔数组</b>，而不是单个布尔值。
</details>

<hr>
<p><strong>14. <code>data=np.random.randn(2,3)</code>，则<code>data.ndim</code>的输出结果是3（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `np.random.randn(2, 3)` 创建的是一个 2 行 3 列的<b>二维数组</b>。因此，其维度数 `.ndim` 是 2。
</details>

<hr>
<p><strong>15. NumPy中的<code>zeros</code>方法和<code>empty</code>方法本质是一样的，都是创建一个全0的数组 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `np.zeros()` 创建并初始化一个全为 0 的数组。`np.empty()` 只分配内存空间，不进行初始化，其内容是内存中残留的“垃圾值”，是不确定的。
</details>

<hr>
<p><strong>16. <code>np.sort</code>方法对数组按位置进行排序。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析**： `np.sort()` 是一个函数，它返回一个排好序的数组<b>副本</b>，不改变原数组。对数组进行原地排序的是 `.sort()` **方法**。
</details>

<hr>
<p><strong>17. 用NumPy数组对象的<code>reshape</code>方法变换维度时会改变原数组。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `.reshape()` 方法返回一个具有新形状的<b>视图</b>，如果可能的话。它不会改变原始数组的形状。
</details>

<hr>
<p><strong>18. <code>bool = np.array(...)</code>，则<code>(bool&gt;0).any()</code>返回True。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 在数值比较中，`True` 被当作 1，`False` 被当作 0。`bool>0` 会产生一个布尔数组，其中原为 `True` 的位置现在也是 `True`。因为结果中至少有一个 `True`，所以 `.any()` 返回 `True`。
</details>

<hr>
<p><strong>19. 使用布尔值索引选择数据时，生成的是数据的视图 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 布尔索引和花式索引（整数数组索引）总是返回数据的<b>副本</b>，而不是视图。
</details>

<hr>
<p><strong>20. 多维Numpy数组的修改元素操作可使用tuple，例如<code>arr2d[(0,0)]=0</code>。 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 使用元组 (tuple) 来指定多维数组中元素的位置是 NumPy 的标准索引方式。`arr2d[(0,0)]`（通常简写为 `arr2d[0,0]`）会精确地选中第 0 行第 0 列的元素，并可以对其进行赋值修改。
</details>

<hr>
<p><strong>21. 对一个array数组进行reshape操作，作用对象的数组形状会发生改变。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 此题与第17题类似。`.reshape()` 返回一个新形状的视图或副本，原始数组的形状不变。
</details>

<hr>
<p><strong>22. 下面代码会报错。<code>arr=[1,2,3];np.sqrt(arr,arr)</code>( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `np.sqrt(arr, out=arr)` 的第二个参数是输出位置。但 `arr` 是一个 Python 列表，而不是 NumPy 数组。NumPy 的 ufunc (如 `np.sqrt`) 通常不能直接将结果写回 Python 列表。即便 `arr` 是 NumPy 数组，如果它是整数类型，将浮点数结果写回整数数组也会导致类型错误。
</details>

<hr>
<p><strong>23. numpy的方法<code>dot</code>和<code>*</code>计算方式没有差别。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `*` 是元素级乘法。`np.dot()` 是矩阵乘法（或向量内积）。两者计算方式和结果完全不同。
</details>

<hr>
<p><strong>24. numpy的<code>mean()</code>函数只能对一维数组使用( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `mean()` 函数可以对任意维度的数组使用，并且可以通过 `axis` 参数指定沿哪个轴计算均值。
</details>

<hr>
<p><strong>25. 如果<code>a.shape=（2，3，4）</code>，那么<code>a.mean(1).shape=（2，3）</code>( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `a.mean(1)` (或 `axis=1`) 会沿着第 1 轴进行聚合，该轴会被“压缩”掉。原形状 `(2,3,4)`，去掉第 1 轴后，结果形状应为 `(2,4)`。
</details>

<hr>
<p><strong>26. 输入<code>np.empty(10)</code>的结果为：<code>array([0., 0., ..., 0.])</code> ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `np.empty()` 只分配内存，不初始化。其内容是内存中的“垃圾值”，是不确定的，通常不是全0。
</details>

<hr>
<p><strong>27. 随机数生成器中的随机数种子相同可以产生不同的随机数组。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 设置相同的随机数种子 (`np.random.seed(...)`) 会保证后续生成的随机数序列是完全相同、可复现的。
</details>

<hr>
<p><strong>28. 对Numpy 数组切片的修改并会影响原数组。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 此题与第10题类似。NumPy 数组的切片是视图，修改切片就是修改原始数组的对应部分。
</details>

<hr>
<p><strong>29. 一个数组对象的<code>itemsize</code>，返回的值是由数组的大小决定的（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `.itemsize` 返回的是数组中<b>单个元素</b>占用的字节数，它由数组的<b>数据类型 (`dtype`)</b> 决定，与数组的大小（元素总数 `.size`）无关。
</details>

<hr>
<p><strong>30. 已知<code>x=np.array([3,5,1,9,6,3])</code>,那么表达式<code>np.argmax(x)</code>的值为3（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `np.argmax()` 返回数组中最大值的<b>第一个</b>出现位置的索引。数组中的最大值是 9，其索引为 3。
</details>

<hr>
<p><strong>31. <code>ar = np.arange(9).reshape(3,3)</code>；<code>ar[:2,0]</code> 会生成一维数组（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `ar[:2, 0]` 中，列索引是单个整数 `0`，这会导致降维。结果是选择了前两行的第 0 列元素，形成一个一维数组 `[0, 3]`。
</details>

<hr>
<p><strong>32. <code>x=np.array([[0,1,2,3,4],[,5,6,7,8]])；x.shape</code>。输出结果是（2，5）（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 代码 `[,5,6,7,8]` 中，第一个逗号前缺少一个值，这是<b>语法错误 (SyntaxError)</b>，代码无法运行。
</details>

<hr>
<p><strong>33. <code>arr=[4,-1,9,16];np.sqrt(arr);arr</code> 以上代码输出的结果为<code>array([2,nan,3,4])</code> ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `np.sqrt(arr)` 会返回一个新的计算结果数组，但不会修改原始的 Python 列表 `arr`。所以最后打印 `arr` 仍然是 `[4, -1, 9, 16]`。
</details>

<hr>
<p><strong>34. 与列表不同，数组中要求所有元素的dtype是一样的，如果传入的参数类型和数组类型不一样，需要按照已有的类型进行转换。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是对 NumPy 数组同构性和类型转换的准确描述。例如，向一个整数数组的某个位置赋浮点数，该浮点数会被截断为整数。
</details>

<hr>
<p><strong>35. <code>np.zeros()</code>生成的矩阵元素属性是Int ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `np.zeros()` 默认生成的元素类型是<b>浮点数 (`float64`)</b>。要生成整数，需要明确指定 `dtype`，如 `np.zeros(..., dtype=int)`。
</details>

<h2 id="第五章：Pandas-核心功能"><a href="#第五章：Pandas-核心功能" class="headerlink" title="第五章：Pandas 核心功能"></a>第五章：Pandas 核心功能</h2><p><strong>1. <code>pd.isnull(frame)</code>与<code>pd.notnull(frame)</code>方法可以判断DataFrame对象frame中的元素是否缺失，返回布尔值DataFrame。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这两个函数（或等价的 `.isnull()` 和 `.notnull()` 方法）都会返回一个与原始 DataFrame 形状相同的布尔型 DataFrame，用于标识每个元素是否为缺失值。
</details>

<hr>
<p><strong>2. 针对DataFrame在行上的标签索引<code>iloc</code>是左闭右开区间,<code>loc</code>是左闭右闭区间。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 这个叙述是<b>错误</b>的。`.iloc` 是基于<b>整数位置</b>的索引，它是“左闭右开”的。`.loc` 是基于<b>标签</b>的索引，它是“左闭右闭”的。题目中将 `iloc` 描述为“标签索引”是错误的。
</details>

<hr>
<p><strong>3. 在DataFrame中，当A是有效的Python变量名时，<code>frame[‘A’]</code>与<code>frame.A</code>返回的结果是相同的（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 Pandas 中两种访问列的方式。字典式 `frame['A']` 总是有效，而属性式 `frame.A` 只有在列名是有效 Python 标识符时才有效。当两者都有效时，返回结果相同。
</details>

<hr>
<p><strong>4. pandas中的Series数据结构可以认为是一个长度固定且有序的字典（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** Series 将一个值序列和一个索引序列对应起来，这在概念上与有序字典（从Python 3.7+开始，字典默认有序）非常相似，其中索引是键，值是值。
</details>

<hr>
<p><strong>5. <code>pandas.to_datetime(date).year</code>可以实现从时间序列（data）中提取年份（ ）</strong></p>
<details>
  <summary style-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `pd.to_datetime()` 返回的是 `Timestamp` 或 `DatetimeIndex`。要从这些对象中提取年份，需要使用 `.dt` 访问器（对于 Series）或直接访问 `.year` 属性（对于单个 Timestamp）。正确的写法应为 `pd.to_datetime(data).year` (对于单个值) 或 `pd.to_datetime(data).dt.year` (对于Series)。
</details>

<hr>
<p><strong>6. 设有<code>s = pd.Series(np.arange(3))</code>，则<code>s.loc[:1]</code>，<code>s.iloc[:2]</code>，<code>s[:2]</code>输出的结果不一样（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `s` 的索引是 `[0, 1, 2]`。
  <ul>
    <li>`s.loc[:1]`：标签切片，左闭右闭，选择标签 0 和 1。</li>
    <li>`s.iloc[:2]`：位置切片，左闭右开，选择位置 0 和 1。</li>
    <li>`s[:2]`：标准的 Series 切片，当索引为整数时，行为与位置切片相同，选择位置 0 和 1。</li>
  </ul>
  这三者输出的结果都是相同的。
</details>

<hr>
<p><strong>7. 从DataFrame中选取的列是数据的视图，而不是拷贝。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 通常情况下，使用 `df['col_name']` 这种方式选择单列返回的是原始 DataFrame 的视图。对这个视图进行修改会影响原始 DataFrame，并可能触发 `SettingWithCopyWarning`。
</details>

<hr>
<p><strong>8. <code>df1 = ...</code> 其中<code>df1.iloc[2:1]=8</code> （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **解析：** 此题缺失判断。但 `df1.iloc[2:1]` 是一个空的切片（起始位置在结束位置之后），对空切片赋值不会修改 DataFrame，也不会报错。

</details>

<hr>
<p><strong>9. 包含Series的字典可以用于构造DataFrame（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是创建 DataFrame 的一种常见且有效的方式。字典的键会成为列名，Series 的值成为列数据，Pandas 会自动对齐 Series 的索引。
</details>

<hr>
<p><strong>10. <code>obj = pd.Series(...)</code>, <code>obj.sort_values()</code>，此操作会将obj中所有的缺失值都放到它的尾部。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `.sort_values()` 方法的 `na_position` 参数默认为 `'last'`，即缺失值 (`NaN`) 会被放在排序结果的末尾。
</details>

<hr>
<p><strong>11. 如果嵌套字典被赋值给DataFrame，pandas会将字典的键作为列，内部字典的键作为行索引（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 `pd.DataFrame()` 处理嵌套字典的标准行为，例如 `pd.DataFrame({'col1': {'row1': 1}})`。
</details>

<hr>
<p><strong>12. <code>pd.DataFrame(np.arange(9).reshape((3,3))))</code>可以建立3列3行的DataFrame。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `np.arange(9).reshape((3,3))` 创建一个 3x3 的 NumPy 数组，`pd.DataFrame()` 可以直接接受这个二维数组来创建一个 3x3 的 DataFrame。
</details>

<hr>
<p><strong>13. 将Series赋值给DataFrame的一列时，Series的索引会按照DataFrame的索引重新排列，并在空缺的地方填充缺失值。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 Pandas 的核心特性之一：自动对齐索引。赋值时，Pandas 会根据 DataFrame 的行索引来匹配 Series 的索引，如果某个 DataFrame 索引在 Series 中找不到，对应位置就会被填充为 `NaN`。
</details>

<hr>
<p><strong>14. 在pandas中，通过<code>isnull</code>和<code>notnull</code>函数检查缺失数据，返回的结果是一样的（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `isnull()` 和 `notnull()` 的功能正好相反。`isnull()` 在缺失值位置返回 `True`，而 `notnull()` 在非缺失值位置返回 `True`。
</details>

<hr>
<p><strong>15. <code>ser=pd.Series(np.arange(3.))</code>，<code>ser.loc[:1]</code>和<code>ser.iloc[:1]</code>的结果是一样的（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `ser` 的索引是 `[0, 1, 2]`。
  <ul>
    <li>`ser.loc[:1]`：标签切片，左闭右闭，选择标签 0 和 1。结果包含两个元素。</li>
    <li>`ser.iloc[:1]`：位置切片，左闭右开，只选择位置 0。结果包含一个元素。</li>
  </ul>
  两者结果不同。
</details>

<hr>
<p><strong>16. <code>[&#39;c&#39;:&#39;d&#39;]</code>是无效的索引 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 对于 Pandas 的 Series 或 DataFrame，如果其索引是字符串标签，那么 `['c':'d']` 这种形式的<b>标签切片</b>是完全有效的。
</details>

<hr>
<p><strong>17. 对DataFrame中选取的列进行修改不会映射到DataFrame中。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 选取的列通常是视图，对其进行修改<b>会</b>映射回原始的 DataFrame。
</details>

<hr>
<p><strong>18. DataFrame的 <code>values</code>属性会把包含在DataFrame中的数据以NumPy数组的形式返回（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析**：这是 `.values` 属性（在新版中推荐使用 `.to_numpy()`）的标准功能。
</details>

<hr>
<p><strong>19. 对于索引值为<code>[‘a’,’b’]</code>的Series对象obj，可以使用<code>obj[1]</code>获取值 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当 Series 的索引是非整数类型时，整数索引会被明确地解释为<b>位置索引</b>。`obj[1]` 会获取第二个元素。
</details>

<hr>
<p><strong>20. <code>4 in pd.Series([4,7,-5,3])</code>返回的结果是True。 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `in` 运算符对于 Series 检查的是<b>索引</b>，而不是值。由于该 Series 的索引是 `[0, 1, 2, 3]`，不包含 `4`，所以返回 `False`。要检查值，应使用 `4 in series.values`。
</details>

<hr>
<p><strong>21. <code>obj=...;</code>对于<code>obj</code>的切片，<code>obj[&quot;b&quot;:&quot;c&quot;]</code>,其输出值为 <code>b 1.0</code>。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 标签切片 `obj["b":"c"]` 是“左闭右闭”的，会包含标签 `'b'` 和 `'c'` 的所有行。结果应为 `'b': 1.0, 'c': 2.0`。
</details>

<hr>
<p><strong>22. 已知<code>obj2 = ...</code>，输入<code>obj2[&#39;a&#39;:&#39;f&#39;]</code>，会正确执行。 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `obj2` 的索引 `['d', 'b', 'a', 'c']` 是无序的。对无序索引进行标签切片，Pandas 无法确定 `'a'` 和 `'f'` 之间的范围，会引发 `KeyError`。
</details>

<hr>
<p><strong>23. <code>states = (&#39;California&#39;, ...)</code>和<code>states = [&#39;California&#39;, ...]</code>都可以执行的。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 第一条语句创建元组，第二条创建列表，都是合法的 Python 语法。
</details>

<hr>
<p><strong>24. 从DataFrame中选取的列是数据的拷贝，而不是视图。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 此题与第7题类似。选取的列通常是视图。
</details>

<hr>
<p><strong>25. Series中的索引值可以重复；DataFrame每列内需是相同的值类型。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这两个都是 Pandas 数据结构的基本特性。
</details>

<hr>
<p><strong>26. <code>a1</code>是一个Series，<code>a2</code>是一个DataFrame，他们都属于Pandas，但是<code>a1.values</code>和<code>a2.values</code>返回的数据类型不一样( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 两者的 `.values` 属性都返回一个 NumPy `ndarray` 对象。区别在于维度，`a1.values` 是一维的，`a2.values` 是二维的，但它们的类型都是 `numpy.ndarray`。
</details>

<hr>
<p><strong>27. 对pandas对象进行切片时：按Label索引进行切片…（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这个叙述准确地总结了 Pandas 切片的三条规则。
</details>

<hr>
<p><strong>28. <code>del</code>在DataFrame中只能够删除列不能够删除行。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** Python 的 `del` 关键字与 Pandas 结合使用时，`del df['col']` 是删除列的有效语法。但没有 `del df[row_index]` 这种删除行的语法，删除行必须使用 `.drop()` 方法。
</details>

<hr>
<p><strong>29. 已知有一个DataFrame对象，可以直接用切片索引它的行列（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `df[...]` 这种直接切片操作是针对<b>行</b>的。要同时索引行和列，必须使用 `.loc` 或 `.iloc` 索引器，如 `df.loc[row_slice, col_slice]`。
</details>

<h2 id="第六章：数据输入输出与接口"><a href="#第六章：数据输入输出与接口" class="headerlink" title="第六章：数据输入输出与接口"></a>第六章：数据输入输出与接口</h2><p><strong>1. 用pandas读取文件时不指定列名时，会报错（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 不指定列名时，Pandas 的 `read_csv` 等函数会默认将文件的<b>第一行</b>作为列名。如果文件没有列名行，可以设置 `header=None`，Pandas 会自动生成整数列名。
</details>

<hr>
<p><strong>2. <code>pd.read_csv(&#39;examples/ex2.csv&#39;, header=0)</code>，<code>header = 0</code>表示取文件中的第一行作为列名。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `header` 参数指定用作列名的行号，索引从 0 开始。`header=0` 明确表示使用文件的第一行作为列名，这也是 `read_csv` 的默认行为。
</details>

<hr>
<p><strong>3. 使用<code>read_csv</code>方法读取文件时，可以通过指定<code>chunksize</code>进行分块读入文件( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `chunksize` 参数用于处理大文件，它会返回一个 `TextFileReader` 对象，可以通过迭代该对象来逐块读取数据。
</details>

<hr>
<p><strong>4. csv产生的数据都是字符串类型的，它不会做任何其它类型的转换（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `read_csv` 会自动进行类型推断，尝试将列转换为数值类型（如 `int64`, `float64`）或日期时间类型。
</details>

<hr>
<p><strong>5. 使用<code>json.loads</code>方法可以将JSON字符串转化为python形式，使用<code>json.dumps</code>可以将python对象转化为JSON。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `json.loads` (load string) 用于反序列化，`json.dumps` (dump string) 用于序列化。
</details>

<hr>
<p><strong>6. DataFrame中的<code>to_csv</code>方法只能导出逗号分隔的文件（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `to_csv` 方法可以通过 `sep` 参数指定任意分隔符，例如 `sep='\t'` 可以导出制表符分隔的文件。
</details>

<hr>
<p><strong>7. JSON对象中的键可以是int形式（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 根据 JSON 规范，对象的键 (key) 必须是<b>字符串</b>。虽然 Python 字典的键可以是整数，但在序列化为标准 JSON 格式时，这些整数键会被转换为字符串。
</details>

<hr>
<p><strong>8. 当要读入的文件没有列名时，可以设置关键字<code>header=None</code>（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `header=None` 明确告诉 Pandas 文件没有列名行，应将所有行都作为数据读取，并自动生成整数列名。
</details>

<hr>
<p><strong>9. 读取的字段由多种不同数量的空格分开时，我们可以通过向<code>sep</code>传入正则表达式来进行读取（ )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当分隔符不固定时，可以使用正则表达式。例如，`sep='\s+'` 可以匹配一个或多个空格作为分隔符。
</details>

<hr>
<p><strong>10. CSV文件在写入的时候<code>data1=data.to_csv(...)</code>，其中<code>sep</code>参数用于制定分隔符（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `to_csv` 的 `sep` 参数用于指定输出文件中的字段分隔符。
</details>

<hr>
<p><strong>11. 使用<code>read_csv()</code>函数必须从头开始逐行读取（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 可以通过 `skiprows` 参数跳过文件开头的任意行，或通过 `skipfooter` 跳过结尾的行。
</details>

<hr>
<p><strong>12. 将pandas数据写入到Excel格式中必须直接调用<code>ExcelWriter</code>（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 最简单的方式是使用 DataFrame 的 `.to_excel()` 方法。只有当需要向同一个 Excel 文件的多个工作表中写入数据时，才需要显式地使用 `ExcelWriter`。
</details>

<hr>
<p><strong>13. pandas中的函数<code>read_html</code>在默认的情况下会解析一个html页面中的所有标签，返回的结果是DataFrame对象的列表 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `pd.read_html()` 会尝试在 HTML 页面中找到所有 `<table>` 标签，并将每个表格都解析成一个 DataFrame，最后将这些 DataFrame 放在一个列表中返回。
</details>

<hr>
<p><strong>14. 语句<code>options.display.max_rows</code>可以调整pandas的最大显示行数，设置显示最开始的行数.( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `pd.options.display.max_rows` 设置的是当 DataFrame 行数超过该值时，Pandas 如何<b>截断显示</b>（例如，显示头尾几行）。它设置的是<b>总的显示行数阈值</b>，而不是只显示最开始的行数。要只看最开始的几行，应使用 `.head(n)` 方法。
</details>

<hr>
<p><strong>15. 使用<code>read_csv()</code>方法读入文件的时候，默认的分隔符是”,”。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `read_csv` 的 "csv" 就代表 "Comma-Separated Values"，其 `sep` 参数默认值为 `','`。
</details>

<hr>
<p><strong>16. <code>na_values</code>可以接受一组用于表示缺失值的字符串 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `na_values` 参数可以接受一个列表或集合，其中包含所有需要在读取时被转换成 `NaN` 的字符串。
</details>

<hr>
<p><strong>17. 在字典中，每列不可以指定不同的缺失值标识。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 可以向 `na_values` 传入一个字典，其中键是列名，值是该列特定的缺失值标识。例如 `na_values={'col_A': ['missing'], 'col_B': [-1]}`。
</details>

<hr>
<p><strong>18. 当要读入的文件没有列名时，可以设置关键字<code>header=None</code> （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 此题与第 8 题相同，叙述正确。
</details>

<hr>
<p><strong>19. 使用<code>read_table</code>方法读取文件时，可以传入<code>seq</code>参数指定分隔符 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 指定分隔符的参数是 `sep` 或 `delimiter`，不是 `seq`。
</details>

<hr>
<p><strong>20. <code>pd.read_csv(&#39;test.csv&#39;,skiprows=1)</code>没有语法错误。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `skiprows=1` 是 `read_csv` 的有效用法，表示跳过文件开头的 1 行。
</details>

<hr>
<p><strong>21. 在<code>read_csv</code>的参数中，<code>skiprows</code>传入的行号必须为列表形式( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `skiprows` 既可以是一个整数（表示从文件开头跳过 N 行），也可以是一个行号列表。
</details>

<hr>
<p><strong>22. 读入文件时，行和列的标签不可以禁止写入。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 在使用 `.to_csv()` 等写入方法时，可以通过设置 `header=False` 来禁止写入列标签，通过设置 `index=False` 来禁止写入行标签。
</details>

<hr>
<p><strong>23. 当读取的txt文件中列名的数量比数据的列数少一个，因此<code>read_table</code>推断第一列应当作为DataFrame的索引。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 Pandas 解析器的一个智能推断行为。当发现列标题行比数据行的字段数少一个时，它会假定第一列没有标题，并将其用作行索引。
</details>

<hr>
<p><strong>24. <code>panda.read_json</code>只能自动将JSON数据集按指定次序转换为Series（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `pd.read_json` 默认会将 JSON 对象或数组转换为 **DataFrame**。只有在特定格式或设置下才会转换为 Series。
</details>

<hr>
<p><strong>25. <code>...nrows=5</code> 和 <code>...chunker.get_chunk(5)</code> 输出结果一样( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `nrows=5` 直接读取文件的前 5 行数据。`chunker = ...chunksize=1000` 创建一个迭代器，`chunker.get_chunk(5)` 从这个迭代器中获取一个大小为 5 行的块。两者都会得到包含文件前 5 行数据的 DataFrame。
</details>

<hr>
<p><strong>26. 使用<code>read_table</code>函数时，可以使用一个正则表达式作为分隔符。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `read_table` 和 `read_csv` 的 `sep` 参数都支持正则表达式。
</details>

<hr>
<p><strong>27. <code>read_csv</code>中的参数<code>header</code>默认为<code>None</code> （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `header` 的默认值是 `0`，表示将文件的第一行作为列名。
</details>

<hr>
<p><strong>28. 为了分块读入文件，可以使用<code>chunksize</code>作为每一块的行数 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 此题与第 3 题类似，叙述正确。
</details>

<hr>
<p><strong>29. HDF不是事务数据库，它最适合用作”一次写多次读“的数据集 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** HDF5 (Hierarchical Data Format) 是一种文件格式，不是数据库。它为高效读写大量科学数据而设计，非常适合“一次写，多次读” (WORM) 的场景。
</details>

<hr>
<p><strong>30. <code>Pd.read_csv()</code>方法中，参数<code>header</code>和<code>names</code>同时设置最终以<code>names</code>作为基准设置列标签 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当 `names` 被指定时，它会覆盖 `header` 的作用。`header` 参数此时只用来告诉 Pandas 文件中的哪一行是旧的列名行，以便可以跳过它。
</details>

<hr>
<p><strong>31. 当要读入的文件没有列名时，可以设置关键字<code>header=0</code> （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `header=0` 是默认行为，它会把文件的<b>第一行当作列名</b>。如果文件没有列名，这样做会导致第一行数据被错误地用作列名。正确的做法是设置 `header=None`。
</details>

<h2 id="第七章：数据清洗与转换"><a href="#第七章：数据清洗与转换" class="headerlink" title="第七章：数据清洗与转换"></a>第七章：数据清洗与转换</h2><p><strong>1. 使用<code>cut</code>方法需要制定具体的边界。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `pd.cut()` 不仅可以接受一个具体的边界列表作为 `bins` 参数，也可以接受一个<b>整数</b>，`cut` 会自动根据数据的最大最小值将范围等分成指定数量的等宽区间。
</details>

<hr>
<p><strong>2. <code>data = pd.Series(...)</code>，<code>data.str.replace(&#39;a&#39;,&#39;d&#39;)</code>其中9会被处理为Nan （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `.str` 访问器下的方法（如 `.replace`）是为字符串设计的。当 Series 中包含非字符串类型的值（如整数 `9`）时，这些方法在这些值上的操作结果是 `NaN`。
</details>

<hr>
<p><strong>3. 默认情况下，<code>fillna</code>方法可以传入指定值来补全缺失值，从而修改了原对象（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `fillna()` 方法默认 `inplace=False`，它会返回一个填充了缺失值的新对象，而<b>不修改</b>原始对象。
</details>

<hr>
<p><strong>4. 在删除dataframe的某一行时,设置关键词<code>inplace=True</code>可以覆盖原有的数据。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 在 Pandas 的许多方法中（如 `.drop()`, `.fillna()` 等），设置 `inplace=True` 会使操作直接在原始对象上生效，并返回 `None`。
</details>

<hr>
<p><strong>5. 对于DataFrame对象，<code>dropna</code>在默认情况下会删除所有值均为NA的行（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `dropna()` 的 `how` 参数默认为 `'any'`，这意味着它会删除<b>任何包含</b> `NaN` 的行，而不是只删除所有值均为 `NaN` 的行。
</details>

<hr>
<p><strong>6. <code>data.dropna(how=&#39;all&#39;)</code>可以删除data中所有包含NA的行（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `how='all'` 表示只删除那些<b>所有值都为 `NaN`</b> 的行/列，而不是所有包含 `NaN` 的行/列。
</details>

<hr>
<p><strong>7. <code>map</code>和<code>replace</code>都可以用于修改一个对象中的子集的值（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `map` 可以通过字典对 Series 中的每个元素进行映射替换。`replace` 也可以通过字典或列表来替换对象中的一个或多个值。两者都可以用于修改值的子集。
</details>

<hr>
<p><strong>8. 处理缺失数据时可以用<code>dropna()</code>方法直接过滤缺失值（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `dropna()` 的核心功能就是删除（过滤掉）含有缺失值的行或列。
</details>

<hr>
<p><strong>9. Data为Series类型，操作<code>data[data.notnull()]</code>与<code>data.dropna()</code>是等价的。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `data.notnull()` 返回一个布尔 Series，其中非缺失值位置为 `True`。使用这个布尔 Series 进行索引，会筛选出所有非缺失值。这与 `.dropna()`（默认删除所有含 `NaN` 的行）的效果是完全等价的。
</details>

<hr>
<p><strong>10. 使用pandas的<code>cut</code>操作返回的是一个DataFrame对象。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `pd.cut()` 返回的是一个特殊的 **Categorical** 对象，它本质上像一个 Series，其值是表示区间的 `Interval` 对象。
</details>

<hr>
<p><strong>11. pandas的索引中不可以包含重复标签（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 与 Python 集合不同，Pandas 的 Index 对象<b>可以</b>包含重复的标签。
</details>

<hr>
<p><strong>12. Python中<code>in</code>关键字、<code>index</code>方法、<code>find</code>方法都可以检查子字符串（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `in` 返回布尔值，`index` 和 `find` 返回索引位置（或在找不到时报错/返回-1），但它们都可以用来检查子字符串是否存在。
</details>

<hr>
<p><strong>13. <code>fillna()</code>方法可以传入字典，实现对不同列的缺失值用不同的值进行填充（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是一个 `fillna` 的常用功能。例如 `df.fillna({'col_A': 0, 'col_B': 'missing'})`。
</details>

<hr>
<p><strong>14. DataFrame中的列索引是自动从1开始的（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 如果不指定，DataFrame 的行索引和列索引都是自动从 <b>0</b> 开始的整数索引。
</details>

<hr>
<p><strong>15. pandas中如果我们不为Series对象指定索引，程序会报错（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 如果不指定索引，Pandas 会自动创建一个从 0 开始的整数 `RangeIndex`。
</details>

<hr>
<p><strong>16. NA和NaN的意思都是一样的 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 在 Pandas 的语境中，NA (Not Available) 是表示缺失数据的通用概念，而 `NaN` (Not a Number) 是其在数值类型（特别是浮点数）中的具体实现。它们通常可以互换使用来指代缺失值。
</details>

<hr>
<p><strong>17. <code>data.index[0]=&#39;aaa&#39;</code>可以将data中第0行的索引变为<code>aaa</code> （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** Pandas 的 Index 对象是<b>不可变的 (immutable)</b>，不能通过索引赋值来修改其内容。这会引发 `TypeError`。
</details>

<hr>
<p><strong>18. 通过<code>index</code>方法查找指定字符的位置，如果字符不存在会返回-1。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 字符串的 `.index()` 方法如果找不到子字符串，会<b>引发 `ValueError`</b>。返回 -1 的是 `.find()` 方法。
</details>

<hr>
<p><strong>19. <code>drop_duplicates</code>函数删除重复行，默认保留第一个观测到的值。 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `drop_duplicates` 的 `keep` 参数默认为 `'first'`。
</details>

<hr>
<p><strong>20. 对于存放数值型数据的DataFrame对象，调用<code>describe</code>方法可以返回各个列的统计数据 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `.describe()` 默认会对 DataFrame 中所有数值类型的列计算描述性统计。
</details>

<hr>
<p><strong>21. Python内建的<code>None</code>值在对象数组中也被当作NA处理。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** Pandas 会将 `None` 识别为缺失值。在 `object` 类型的数组中，它会保持为 `None`，但在 `isnull()` 等函数中会被当作 `NA`。如果数组是数值类型，`None` 会被强制转换为 `NaN`。
</details>

<hr>
<p><strong>22. 使用<code>rename</code>方法对DataFrame对象<code>df</code>进行重命名将会返回一个新的对象。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `.rename()` 方法默认 `inplace=False`，返回一个重命名了索引或列的新 DataFrame 对象。
</details>

<hr>
<p><strong>23. pandas中用<code>cut</code>函数进行分箱得到的分组区间只能是前开后闭（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `cut` 默认是左开右闭 `(a, b]`，但可以通过设置 `right=False` 来实现左闭右开 `[a, b)`。
</details>

<hr>
<p><strong>24. pandas中的<code>cut</code>函数可以通过传入参数实现两端均封闭。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 可以通过 `include_lowest=True` 参数来确保第一个区间的左边界是封闭的。例如，`pd.cut(data, bins=[0,1,2], include_lowest=True)` 会产生 `[-0.001, 1.0]` 和 `(1.0, 2.0]`。
</details>

<hr>
<p><strong>25. 在DataFrame对象中，使用<code>fillna</code>来补全缺失值时，返回的是一个新对象。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 此题与第3题类似。`fillna` 默认 `inplace=False`，返回新对象。
</details>

<hr>
<p><strong>26. <code>dropna</code> 默认情况下会删除包含缺失值的列。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `dropna` 的 `axis` 参数默认为 `0`，即默认删除包含缺失值的<b>行</b>。
</details>

<hr>
<p><strong>27. 语句<code>np.sign(data)</code>根据数据中的值的正负分别生成0和1的值 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `np.sign()` 会返回：正数 -> `1`，负数 -> `-1`，零 -> `0`。
</details>

<hr>
<p><strong>28. <code>dropna()</code>函数的<code>axis</code>和<code>how</code>参数的默认值分别为0，<code>any</code>( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `axis` 默认为 0 (行)，`how` 默认为 'any' (任何一个 `NaN` 就删除)。
</details>

<hr>
<p><strong>29. <code>fillna</code>方法的参数可以传入字典为不同列设置不同的填充值 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 此题与第13题类似，叙述正确。
</details>

<h2 id="第八章：数据合并与重塑"><a href="#第八章：数据合并与重塑" class="headerlink" title="第八章：数据合并与重塑"></a>第八章：数据合并与重塑</h2><p><strong>1. 默认情况下，<code>concat</code>方法是沿着<code>axis=0</code>的轴向生效的（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `pd.concat` 的 `axis` 参数默认为 `0`，表示沿行方向进行拼接（垂直堆叠）。
</details>

<hr>
<p><strong>2. NumPy中的<code>concatenate</code>函数默认情况下是进行横向拼接（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `np.concatenate` 的 `axis` 参数默认为 `0`，表示沿第一个轴（行方向）进行拼接（垂直堆叠），而不是横向拼接（`axis=1`）。
</details>

<hr>
<p><strong>3. <code>merge</code>函数会在没有指定连接键的情况下，自动将重叠列名作为连接的键（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 如果不通过 `on`, `left_on`, `right_on` 等参数指定连接键，`pd.merge` 会自动使用两个 DataFrame 中共有的列名作为连接键。
</details>

<hr>
<p><strong>4. 如果不是所有的级别值都能在各分组中找到，则<code>unstack</code>操作会引入缺失数据（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `unstack` 在将索引层级旋转到列时，如果某个新的行列组合在原始数据中不存在，该位置就会用 `NaN` 填充。
</details>

<hr>
<p><strong>5. <code>swaplevel</code>接收两个层级序号或名称，将原对象的层级进行变更。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `swaplevel` 会返回一个层级交换后的<b>新对象</b>，而<b>不改变</b>原对象。
</details>

<hr>
<p><strong>6. 分层索引中“内部层级”是不可以选择的 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 可以通过多种方式选择内部层级，例如使用元组 `df.loc[('outer_key', 'inner_key')]`，或者通过 `.xs()` 方法。
</details>

<hr>
<p><strong>7. 在DataFrame中拆堆时，被拆堆的层级会变为结果中最低（level最大）的层级（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `unstack` 会将指定的行索引层级移动到列索引中，并成为新的列索引层级中的最内层（即最低层级）。
</details>

<hr>
<p><strong>8. DataFrame的<code>join</code>方法，能更为方便地实现按索引合并…但要求没有重叠的列（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `.join()` 是一个方便的按索引连接的方法。如果两个 DataFrame 有重叠的列名，`join` 会引发 `ValueError`，除非你使用 `lsuffix` 或 `rsuffix` 参数来区分它们。
</details>

<hr>
<p><strong>9. 一个分层索引的Series对象使用<code>unstack</code>方法会修改原对象（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `unstack` 会返回一个重塑后的新对象（通常是 DataFrame），不修改原始的 Series。
</details>

<hr>
<p><strong>10. 使用<code>merge</code>函数进行列-列连接时，传递的DataFrame索引对象会被丢弃。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当 `merge` 基于列进行连接时，默认情况下，结果会生成一个新的从 0 开始的整数索引，原始的行索引会被丢弃。
</details>

<hr>
<p><strong>11. 在使用<code>pandas.melt</code>的时候，需要指明作为分组目标的列（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `pd.melt` 需要指明的是作为<b>标识符变量</b>的列（通过 `id_vars` 参数），而不是分组目标。未在 `id_vars` 中指定的列会被“融合”到 `variable` 和 `value` 两列中。
</details>

<hr>
<p><strong>12. <code>combine_first</code>可用于拼接重复数据，用一个对象中的值填充另一个对象中的缺失值（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是对 `combine_first` 功能的准确描述。它会用调用对象（第二个对象）的值来“修补”或“填充”第一个对象中的 `NaN` 值。
</details>

<hr>
<p><strong>13. 在数据透视表中，加入<code>margins=False</code>,可以在下方显示一些总和数据。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 要显示总计（小计），需要设置 <b>`margins=True`</b>。`margins=False` 是默认行为，不显示总计。
</details>

<hr>
<p><strong>14. 以列表（或者数组）作为Series的索引可以构造分层索引。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 要构造分层索引，需要传入一个由<b>元组组成的列表</b>，或者使用 `pd.MultiIndex.from_...` 方法。直接传入一个列表（如 `['a', 'b']`）只会创建单层索引。
</details>

<hr>
<p><strong>15. 在分级索引中，可以通过<code>level</code>选项并通过改变轴向来进行聚合。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 像 `.sum()`, `.mean()` 等聚合方法都接受 `level` 参数来指定在哪个索引层级上进行聚合，也接受 `axis` 参数来指定是在行索引还是列索引上操作。
</details>

<hr>
<p><strong>16. <code>unstack</code>操作的只能是最内层，<code>stack</code>也是如此 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `unstack` 和 `stack` 默认操作最内层，但都可以接受一个 `level` 参数（层级名称或编号）来指定操作任意一个层级。
</details>

<hr>
<p><strong>17. 默认情况下，<code>merge</code>函数会联合左连接和右连接的效果。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `merge` 默认是<b>内连接 (`inner`)</b>。联合左连接和右连接效果的是<b>外连接 (`outer`)</b>。
</details>

<hr>
<p><strong>18. 使用<code>merge</code>函数进行列-列连接时，传递的DataFrame索引对象会被丢弃。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 此题与第 10 题相同，叙述正确。
</details>

<hr>
<p><strong>19. 通过给出层级排序函数<code>sort_index</code>函数中的<code>level</code>选项，可以指明对这一个层级的索引排序（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `sort_index` 的 `level` 参数专门用于在多重索引中指定按哪个层级进行排序。
</details>

<hr>
<p><strong>20. <code>concat</code>函数对两个含有重叠索引的Series进行连接后，重叠索引对应的值为连接前两个重叠索引对应的值之和（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `concat` 只是简单地将 Series 拼接在一起。如果存在重叠的索引，结果中会保留这些重复的索引及其各自对应的值，而不会进行任何算术运算。
</details>

<hr>
<p><strong>21. DataFrame的<code>join</code>方法进行连接键上的左连接，完全保留左边DataFrame的行索引（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `.join()` 方法默认 `how='left'`，即左连接，它会以调用该方法的 DataFrame（左边）的索引为基准进行连接。
</details>

<hr>
<p><strong>22. 若一个具有二重行列索引的数据，使用<code>data.loc(axis=0)[0,1]</code>命令，获得的数据保留二重索引。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `data.loc(axis=0)[0,1]` 是错误的语法。`.loc` 不是一个函数，不能用 `()` 调用。正确的语法是 `data.loc[...]`。
</details>

<hr>
<p><strong>23. DataFrame的多对多连接是行的笛卡尔积（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 在 `merge` 操作中，如果左表的连接键有 M 个匹配项，右表的连接键有 N 个匹配项，那么多对多连接会产生 M * N 行的笛卡尔积。
</details>

<hr>
<p><strong>24. <code>groupby()</code>后，使用<code>agg()</code>可以…但不能对不同的列使用不同的函数( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `.agg()` 的一个核心功能就是可以通过传入一个字典，来对不同的列应用不同的聚合函数。例如 `df.groupby('key').agg({'col_A': 'sum', 'col_B': 'mean'})`。
</details>

<hr>
<p><strong>25. 对两个Series数组调用<code>concat</code>方法，…如果设定<code>axis=1</code>，会生成一个DataFrame （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `axis=0` (默认) 会将两个 Series 垂直拼接成一个更长的 Series。`axis=1` 会将两个 Series 水平并列，每个 Series 成为一列，从而构成一个 DataFrame。
</details>

<hr>
<p><strong>26. DataFrame的<code>set_index</code>函数会生成一个新的DataFrame。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `set_index` 默认 `inplace=False`，返回一个设置了新索引的新 DataFrame 对象。
</details>

<hr>
<p><strong>27. <code>stack</code>(堆叠)会将行中的数据透视到列中（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `stack` (堆叠) 是将<b>列</b>中的数据“堆叠”到<b>行</b>上，形成一个更长的、带有更多层级索引的 Series。将行透视到列的操作是 `unstack`。
</details>

<hr>
<p><strong>28. <code>swaplevel</code>接收两个层级序号或层级名称，返回一个进行了层级变更的新对象（但是原数据是不变的）( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是对 `swaplevel` 功能的准确描述。
</details>

<hr>
<p><strong>29. <code>concat</code>函数中，<code>join</code>默认的连接方式是<code>&#39;inner&#39;</code>（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `concat` 的 `join` 参数默认为 `'outer'`，即取所有轴上索引的并集。
</details>

<hr>
<p><strong>30. <code>concat</code>函数中，如果传入了<code>keys</code>和&#x2F;或<code>levels</code>参数，则该参数不能用于多层索引的层级名称（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `keys` 参数用于提供新创建的层级的标签，而 `names` 参数（不是`levels`）用于为这些层级命名。`levels` 是 MultiIndex 的一个属性。这个表述混淆了参数，是错误的。
</details>

<hr>
<p><strong>31. 在<code>concat</code>方法中传入参数<code>ignore_index</code>参数将忽略轴向索引 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `ignore_index=True` 会使 `concat` 忽略原始对象的索引，并生成一个新的从 0 开始的整数索引。
</details>

<hr>
<p><strong>32. <code>merge</code>函数中<code>on</code>参数所需要连接的列名并不必须在两边的DataFrame对象中都出现。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `on` 参数指定的是在两个 DataFrame 中都<b>共同存在</b>的列名。如果两边的列名不同，需要分别使用 `left_on` 和 `right_on`。
</details>

<hr>
<p><strong>33. …<code>frame.reset_index(1)</code>和<code>frame.sort_index(level=1)</code>返回的结果相同。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `reset_index(1)` 会将第 1 层索引（key2）变成一个数据列。`sort_index(level=1)` 会根据第 1 层索引的值对行进行排序。两者功能和返回结果的结构完全不同。
</details>

<hr>
<p><strong>34. <code>sort_index</code>只能在单一层级上对数据进行排序 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `sort_index` 的 `level` 参数可以接受一个<b>列表</b>，从而按多个层级的先后顺序进行排序。
</details>

<h2 id="第九章：数据可视化"><a href="#第九章：数据可视化" class="headerlink" title="第九章：数据可视化"></a>第九章：数据可视化</h2><p><strong>1. <code>fig.add_subplot(2, 3, 5)</code>，第3个参数的含义是在创建的6个子图中，它是第五个（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `add_subplot(nrows, ncols, index)` 中的 `index` 参数是从 1 开始计数的，表示子图在网格中的位置。对于 2x3 的网格，`index=5` 指的是第二行第二列的子图，也就是第5个。
</details>

<hr>
<p><strong>2. DataFrame的<code>plot</code>方法可以在同一个子图中将每一列绘制为不同的折线，并自动生成图例（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 `df.plot()` 的标准行为。它会为 DataFrame 的每一列（通常是数值列）绘制一条折线，并使用列名作为标签自动生成图例。
</details>

<hr>
<p><strong>3. <code>matplotlib</code>和<code>seaborn</code>都是可以用于绘图的包。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** Matplotlib 是基础绘图库，Seaborn 是基于 Matplotlib 的高级封装，两者都是 Python 中主流的数据可视化库。
</details>

<hr>
<p><strong>4. 在图表中添加图形时，需要生成patch对象<code>shp</code>，再调用<code>add_patch(shp)</code>将它加入到子图（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `Patch` 是 Matplotlib 中几何形状的基类。添加形状的标准流程就是先创建 Patch 对象（如 `plt.Rectangle`, `plt.Circle`），然后使用 Axes 对象的 `.add_patch()` 方法将其添加到子图中。
</details>

<hr>
<p><strong>5. <code>fig.add_subplot</code>返回的是Axes Subplot对象（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `fig.add_subplot()` 和 `plt.subplots()` 返回的子图对象都是 `matplotlib.axes.Axes` 的实例（或其子类），通常称为 Axes 对象或子图对象。
</details>

<hr>
<p><strong>6. <code>matplotlib</code>并不检查标签是否重叠（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** Matplotlib 的默认布局算法通常不会主动检查和避免坐标轴刻度、标题等文本标签的重叠，有时需要用户手动调用 `plt.tight_layout()` 或调整图形参数来解决。
</details>

<hr>
<p><strong>7. <code>regplot</code>是<code>seaborn</code>中的绘制折线图的方法（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `regplot` 用于绘制<b>散点图</b>并拟合一条线性<b>回归线</b>。Seaborn 中绘制折线图的主要函数是 `lineplot`。
</details>

<hr>
<p><strong>8. 对于折线图，后续的点默认是线性内插（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** Matplotlib 的 `plot` 函数在绘制折线图时，会用直线连接相邻的数据点，这在视觉上是一种线性插值的效果。
</details>

<hr>
<p><strong>9. 运行代码<code>fig.add_subplot（2，2，0）</code>生成的是2×2图片中的第一个子图（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `add_subplot(nrows, ncols, index)` 中的 `index` 参数是从 <b>1</b> 开始计数的，`index=0` 是无效的，会引发 `ValueError`。
</details>

<hr>
<p><strong>10. 使用分面网格是利用多种分组变量对数据进行可视化的方式（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 分面网格（Facet Grid），如 Seaborn 中的 `catplot` 或 `relplot`，核心思想就是根据一个或多个分类变量的值将数据划分到不同的子图中，从而在多个维度上进行比较和可视化。
</details>

<hr>
<p><strong>11. 绘制图表时可以通过传递<code>label</code>参数添加图例来区分不同的绘图元素 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 在 `plt.plot` 等绘图函数中设置 `label` 参数，然后调用 `plt.legend()`，即可显示图例。
</details>

<hr>
<p><strong>12. DataFrame对象调用<code>plot</code>方法时，可以通过传递<code>subplots=True</code>来使得对象的每一列绘制在独立的子图中（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 `subplots=True` 参数的正确功能描述。
</details>

<hr>
<p><strong>13. <code>plt.plot([2,3, 6, 7,8], &#39;g--o&#39;)</code>与<code>plt.plot([2,3, 6, 7,8], &#39;go--&#39;)</code>生成的图形不一样。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 在 Matplotlib 的格式字符串中，颜色、标记和线型的顺序是任意的。`'g--o'` 和 `'go--'` 都表示：颜色绿色(`g`)，线型虚线(`--`)，标记圆点(`o`)。两者生成的图形是完全一样的。
</details>

<hr>
<p><strong>14. pandas对象的<code>plot.barh</code>方法绘制的是垂直的柱状图（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `barh` 中的 `h` 代表 horizontal（水平）。`.plot.barh()` 绘制的是<b>水平</b>柱状图。`.plot.bar()` 才是绘制垂直柱状图。
</details>

<hr>
<p><strong>15. matplotlib在设置x轴刻度的时候，区间长度必须一致。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** Matplotlib 的刻度设置非常灵活，完全可以设置不均匀的刻度位置。例如 `plt.xticks([0, 1, 5, 10])`。
</details>

<hr>
<p><strong>16. matplotlib绘制的图位于Figure对象中，可以使用<code>plt.figure()</code>调用 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `Figure` 是 Matplotlib 中最高层级的容器，包含了所有的绘图元素。`plt.figure()` 用于<b>创建</b>一个新的 `Figure` 对象，或者获取当前活动的 `Figure` 对象。
</details>

<hr>
<p><strong>17. 通过使用<code>shareX</code>、<code>shareY</code>可以使得子图分别拥有相同的x轴和y轴 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 在 `plt.subplots()` 函数中，设置 `sharex=True` 和 `sharey=True` 可以让所有子图共享相同的 x 轴和 y 轴范围及刻度，这对于比较不同子图非常有用。
</details>

<hr>
<p><strong>18. <code>set_xticks</code>在数据范围内设定刻度的位置，而不设置刻度的标签。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `ax.set_xticks()` 用于设置 x 轴<b>主刻度线的位置</b>。要设置这些位置对应的<b>标签文本</b>，需要使用 `ax.set_xticklabels()`。
</details>

<hr>
<p><strong>19. <code>plt.savefig</code>函数可以将图片保存到文件中，并且只能以<code>svg</code>格式存储（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `savefig` 支持多种文件格式，如 `.png`, `.jpg`, `.pdf`, `.svg` 等，通常根据你提供的文件扩展名自动推断格式。
</details>

<hr>
<p><strong>20. 在绘制直方图的参数中，<code>bins</code>的默认参数是10。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 在 `plt.hist()` 和 Pandas 的 `.plot.hist()` 中，如果不指定 `bins` 参数，默认会将数据划分到 10 个箱子中。
</details>

<hr>
<p><strong>21. 假设有一个figure对象<code>fig</code>，则<code>fig.add_subplot(224)</code>和<code>fig.add_subplot(2,2,4)</code>执行的结果相同。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `add_subplot` 支持一种三位数的简写形式，其中百位是行数，十位是列数，个位是索引。因此 `add_subplot(224)` 等价于 `add_subplot(2, 2, 4)`。
</details>

<hr>
<p><strong>22. 默认情况下，Series和DataFrame的<code>plot()</code>方法绘制的是条形图（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 默认绘制的是<b>线图 (line plot)</b>。
</details>

<hr>
<p><strong>23. <code>fig=plt.figure()</code>随后<code>fig.plot()</code>没有问题。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `Figure` 对象本身没有 `.plot()` 方法。绘图是在 `Axes` (子图) 对象上进行的。正确的做法是先用 `fig.add_subplot()` 创建一个子图 `ax`，然后调用 `ax.plot()`。
</details>

<hr>
<p><strong>24. <code>plot</code>函数中’b’代表黑色 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `'b'` 代表蓝色 (blue)，`'k'` 代表黑色 (black)。
</details>

<hr>
<p><strong>25. 代码<code>plt.xlim（[0, 10]）</code>的目的是将x轴的范围设置为0到10。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 `plt.xlim()` 函数的标准用法，也可以用 `plt.xlim(0, 10)`。
</details>

<hr>
<p><strong>26. 使用<code>value_counts:s.value_counts().plot.bar()</code>可以有效地对Series值进行可视化。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `s.value_counts()` 会计算 Series 中每个唯一值的出现频率，返回一个新的 Series。对其调用 `.plot.bar()` 可以非常直观地将这些频率以柱状图的形式展示出来。
</details>

<hr>
<p><strong>27. <code>plt.subplots</code>方法可以创建一个新的Figure，并返回一个含有已创建的subplot对象的NumPy数组。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `fig, axes = plt.subplots(...)` 返回一个 Figure 对象 `fig` 和一个包含所有子图 (Axes) 对象的 NumPy 数组 `axes`（如果只创建一个子图，则返回单个 Axes 对象）。
</details>

<hr>
<p><strong>28. <code>matplotlib</code>会自动检查标签是否重叠（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 此题与第 6 题类似，Matplotlib 默认不会检查标签重叠。
</details>

<hr>
<p><strong>29. <code>ax.scatter(np.arange(10), np.arange(10))</code>可以绘制一个x和y取值都在1-10之间的散点图。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `np.arange(10)` 生成的是从 <b>0 到 9</b> 的整数序列，而不是 1 到 10。
</details>

<hr>
<p><strong>30. DataFrame直接进行绘图时，默认把columns当成x轴（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 默认情况下，`df.plot()` 使用 DataFrame 的<b>索引 (index)</b> 作为 x 轴，每一列 (columns) 作为一条独立的 y 轴序列。
</details>

<h2 id="第十章：高级数据分析技术"><a href="#第十章：高级数据分析技术" class="headerlink" title="第十章：高级数据分析技术"></a>第十章：高级数据分析技术</h2><p><strong>1. 调用<code>groupby</code>方法生成一个GroupBy对象可以直接进行输出。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** GroupBy 对象本身是一个中间对象，它包含了分组信息但没有进行任何计算。直接打印它只会显示其类型信息，如 `<pandas.core.groupby.generic.DataFrameGroupBy object ...>`，而不会显示分组后的数据。
</details>

<hr>
<p><strong>2. <code>quantile</code>（分位数）是Series的方法所以也可以用来聚合。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 任何能从数组中产生标量值的函数都可以作为聚合函数。`quantile()` 是 Series 的一个有效方法，可以计算分位数（一个标量），因此可以用于 GroupBy 对象的聚合，例如 `grouped.quantile(0.5)`。
</details>

<hr>
<p><strong>3. 在没有特定指明对DataFrame对象的哪一列进行计算时，默认情况下会对所 有的数值列进行聚合（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当对一个 GroupBy 对象调用聚合方法（如 `.mean()`, `.sum()`）时，如果未选择特定列，该方法会自动应用到所有可进行该运算的列上，通常是数值类型的列。
</details>

<hr>
<p><strong>4. 聚合数据必须返回行索引，并且自己创建的聚合函数是可以直接使用的（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 聚合后的数据，其索引是分组键，不一定是行索引。自定义的聚合函数可以通过 `.agg()` 或 `.apply()` 方法使用。
</details>

<hr>
<p><strong>5. 使用<code>groupby</code>方法分组时分组键可以是多种形式的，而且键的类型也不一定完全相同（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** GroupBy 的分组键 `by` 参数非常灵活，可以接受列名、Series、数组、函数等，它们的类型也可以不同。
</details>

<hr>
<p><strong>6. 分层索引的数据集可以在某个指定的层级上进行聚合（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** GroupBy 的 `by` 参数和聚合方法（如 `.sum()`）的 `level` 参数都可以用来指定在哪个索引层级上进行分组和聚合。
</details>

<hr>
<p><strong>7. 若传入一组函数或函数名，得到的DataFrame的列就会以相应的函数命名（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当向 `.agg()` 传入一个函数列表时，例如 `grouped.agg(['mean', 'std'])`，结果 DataFrame 的列名会自动以函数名（如 'mean', 'std'）作为新的层级。
</details>

<hr>
<p><strong>8. 聚合只是分组运算中的一种…它只是接受能够将一维数组简化为标量值的函数。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是对聚合 (aggregation) 的准确定义。它是一种将一组值（如一个分组内的数据）转换为一个单一标量值（如均值、和、最大值等）的数据转换过程。
</details>

<hr>
<p><strong>9. 对多个分组键的GroupBy对象进行迭代，生成的元组序列中的第一个元素是键值的元组（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当按多个键（如 `df.groupby(['key1', 'key2'])`）分组并迭代时，每次迭代返回 `(group_name, sub_df)`。其中 `group_name` 是一个包含该组所有键值的元组，例如 `('a', 'one')`。
</details>

<hr>
<p><strong>10. <code>Crosstab</code>的前两个参数可以是数组、Series、或者数组的列表（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `pd.crosstab` 的 `index` 和 `columns` 参数非常灵活，可以接受 Series、数组或列表，或者这些类型的列表（用于创建多级交叉表）。
</details>

<hr>
<p><strong>11. 对于<code>groupby</code>中的<code>size</code>方法，分组键中的任何缺失值都会被排除在结果之外（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 默认情况下，`groupby` 会忽略分组键中的 `NaN` 值。`.size()` 会计算每个有效分组的大小，但它本身不处理分组键的缺失。
</details>

<hr>
<p><strong>12. <code>apply</code>方法是将对象拆分为多块，在每一块都会调用传递的函数（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是对 GroupBy 的 "Split-Apply-Combine" 模式中 "Apply" 步骤的准确描述。`apply` 方法会对每个分组（块）执行传入的函数。
</details>

<hr>
<p><strong>13. 使用字典构造传给<code>groupby</code>的数组时，字典的键必须与对象的长度一致（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 当使用字典进行分组时，字典的键应该与被分组<b>轴的索引标签</b>相对应，而不是与对象的长度一致。
</details>

<hr>
<p><strong>14. 默认情况下，<code>groupby</code>在<code>axis = 1</code>的轴向上分组（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `groupby` 的 `axis` 参数默认为 `0`，即默认按行进行分组。
</details>

<hr>
<p><strong>15. 分组键中有缺失值会导致程序报错 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `groupby` 默认会忽略分组键中的 `NaN` 值，不会报错。
</details>

<hr>
<p><strong>16. 分组信息不能以非数组形式存在 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 分组信息（分组键）可以是多种形式，如函数、字典、Series，不限于数组。
</details>

<hr>
<p><strong>17. 在没有特定指明对DataFrame对象的哪一列进行计算时，<code>agg</code>方法默认情况下会对所有的数值列进行聚合（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 此题与第 3 题类似，叙述正确。
</details>

<hr>
<p><strong>18. …执行<code>df.groupby([&#39;key1&#39;,&#39;key2&#39;])[&#39;data2&#39;].mean()</code>可以获得<code>data2</code>列的均值并以DataFrame的形式返回结果（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `df.groupby(...)['data2']` 选择了一列，这是一个 GroupBy Series 对象。对其调用 `.mean()` 会返回一个<b>Series</b>，其索引是分组键 `('key1', 'key2')`。
</details>

<hr>
<p><strong>19. 若<code>df</code>是一个DataFrame对象，则默认情况下，<code>df</code>中的所有的数值列都可以聚合。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 此题与第 3 题和第 17 题类似，叙述正确。
</details>

<hr>
<p><strong>20. 假设有DataFrame对象<code>df</code>，<code>key1</code>是<code>df</code>中的列，则<code>df.groupby(&#39;key1&#39;).mean()</code>等价于<code>df.groupby([&#39;key1&#39;]).mean()</code>。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 按单列分组时，传入字符串 `'key1'` 和包含单个字符串的列表 `['key1']` 是等价的。
</details>

<hr>
<p><strong>21. 使用自定义的聚合函数时需要将其传递给<code>agg</code>方法 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `.agg()` 是应用一个或多个聚合函数（包括自定义函数）到分组上的标准方法。
</details>

<hr>
<p><strong>22. 使用含有原数据不存在的分组键的字典或Series进行分组会出现报错 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 不会报错。如果分组字典或 Series 的键在被分组对象的索引中找不到，这些键值对会被忽略。
</details>

<hr>
<p><strong>23. <code>groupby</code>的参数只可以是列名，不可以是index名。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 可以通过 `level` 参数按索引的层级名称或编号进行分组。
</details>

<hr>
<p><strong>24. <code>cumsum</code>函数不会对<code>df</code>的索引进行排序。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `cumsum()` 在计算累积和时，是按照数据现有的顺序进行的，不会改变或排序索引。
</details>

<hr>
<p><strong>25. 对从DataFrame创建的GroupBy对象用列表或数组进行索引时，返回的是分组的DataFrame( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当对一个 GroupBy 对象使用 `[]` 选择一列或多列时（如 `grouped[['col_A', 'col_B']]`），它会返回一个新的、只包含这些选定列的 GroupBy 对象，可以继续进行聚合等操作。
</details>

<hr>
<p><strong>26. 返回的聚合数据…取消这种模式，在调用<code>groupby</code>的时候设定<code>as_index=True</code>即可。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `as_index=True` 是默认行为，它会使分组键成为结果的索引。要取消这种模式（即让分组键保留为数据列），需要设置 <b>`as_index=False`</b>。
</details>

<hr>
<p><strong>27. <code>cut</code>返回的Categorical对象不能直接传递给<code>groupby</code> （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `pd.cut()` 返回的 Categorical 对象是进行分箱分析时 `groupby` 的理想分组键。
</details>

<hr>
<p><strong>28. <code>pandas</code>提供了<code>crosstab()</code>函数…返回新的<code>DataFrame</code>对象。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是对 `pd.crosstab` 功能的准确描述。
</details>

<hr>
<p><strong>29. <code>apply</code>函数只可以传入函数 ( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 与 `.agg()` 或 `.transform()` 不同，`.apply()` 不接受像 `'mean'` 这样的字符串快捷方式，它必须接受一个可调用的函数对象。
</details>

<hr>
<p><strong>30. 在用<code>groupby</code>方法对DataFrame对象进行分组处理时，…可以是字符串类型的列名、其他python对象…以及python的函数。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 此题与第 5 题类似，准确描述了 `groupby` 分组键的灵活性。
</details>

<hr>
<p><strong>31. <code>Goupby</code> 对象会生成包含组名和数据块的二位元组序列 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 迭代一个 GroupBy 对象时，每次会产生一个 `(group_name, sub_dataframe)` 形式的二元元组。
</details>

<hr>
<p><strong>32. 由于<code>quantile</code>并不是显式的为GroupBy对象实现的，因此不能用于聚合 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 此题与第 2 题类似。虽然 `.quantile()` 不是像 `.mean()` 那样直接的 GroupBy 方法，但它可以作为有效的聚合函数通过 `.agg()` 或 `.apply()` 来使用。
</details>

<h2 id="第十一章：时间序列数据的处理和分析"><a href="#第十一章：时间序列数据的处理和分析" class="headerlink" title="第十一章：时间序列数据的处理和分析"></a>第十一章：时间序列数据的处理和分析</h2><p><strong>1. <code>datetime.strptime</code>可以在已知格式的情况下转换日期。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `datetime.strptime(string, format)` 的核心功能就是将一个字符串按照指定的格式解析为 `datetime` 对象。
</details>

<hr>
<p><strong>2. 不能创建含有重复索引的时间序列（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** Pandas 的时间序列（以及其他任何 Series/DataFrame）的索引都<b>可以</b>包含重复的标签。
</details>

<hr>
<p><strong>3. <code>Timestamp</code>与<code>datetime</code>都是时间类型，但是<code>timestamp</code>只使用<code>datetime</code>一半的存储空间。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** Pandas 的 `Timestamp` 对象内部使用一个 64 位整数（8字节）来存储纳秒级精度的时间。Python 的 `datetime` 对象通常也占用相似或更多的空间。说 `Timestamp` 只使用一半空间是不准确的。
</details>

<hr>
<p><strong>4. 如果时间序列是含有重复索引的，进行索引得到的结果是切片（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当使用一个在索引中重复出现的标签进行索引时，Pandas 会返回一个包含所有匹配该标签的行的新 Series 或 DataFrame，这在概念上是一个“切片”或子集。
</details>

<hr>
<p><strong>5. 不同索引的时间序列之间的算术运算在日期上自动对齐（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 Pandas 的核心特性之一。在进行算术运算时，Pandas 会自动按索引对齐数据，对于只存在于一方的索引，结果会是 `NaN`。
</details>

<hr>
<p><strong>6. <code>pd.date_range(&#39;2000-01-01&#39;,&#39;2000-01-03 23:59&#39;,freq=&#39;0.545H&#39;)</code>是不能运行的。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `freq` 参数可以接受小数，表示非整数倍的频率。`'0.545H'` 是一个有效的频率字符串，表示 0.545 个小时。代码可以正常运行。
</details>

<hr>
<p><strong>7. 以时间戳作为索引的Series可以传递能解释为日期的字符串进行索引。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 Pandas 时间序列索引的便利之处。你可以使用 `'2011-01-10'`、`'1/10/2011'` 等字符串来索引一个 `DatetimeIndex`，Pandas 会自动解析它们。
</details>

<hr>
<p><strong>8. <code>resample</code>后使用<code>ohlc</code>聚合函数可以获得包含开端-峰值-谷值-结束四种聚合值列的DataFrame（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `ohlc` (Open-High-Low-Close) 是一种专门为金融时间序列设计的聚合函数，它会在每个重采样周期内计算开盘价（第一个值）、最高价、最低价和收盘价（最后一个值）。
</details>

<hr>
<p><strong>9. 在<code>date_range</code>的<code>freq</code>参数传入“1h10min”是无效的（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** Pandas 的频率字符串支持组合。`'1h10min'` 是一个有效的频率，表示 1 小时 10 分钟。
</details>

<hr>
<p><strong>10. 如果两个时间区间拥有相同的频率，则它们的差是它们之间的单位数。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 对两个相同频率的 `Period` 对象进行减法运算，会得到它们之间相差的频率单位数量。例如 `pd.Period('2011-03', 'M') - pd.Period('2011-01', 'M')` 的结果是 `2`。
</details>

<hr>
<p><strong>11. 时间序列进行索引和选择时，传入的日期字符串格式必须与时间序列中的格式相同（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 此题与第 7 题类似。Pandas 的日期解析器非常灵活，不需要传入的字符串格式与 `DatetimeIndex` 的内部格式完全一致。
</details>

<hr>
<p><strong>12. 所有使用<code>datetime</code>对象的地方都可以使用<code>Timestamp</code>（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** Pandas 的 `Timestamp` 对象是 Python 内置 `datetime` 对象的兼容替代品，并提供了更高的时间精度（纳秒）和一些额外功能。在大多数情况下，它们可以互换使用。
</details>

<hr>
<p><strong>13. 两个时区不同的时间序列联合的结果是UTC时间（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当合并或操作两个具有不同时区的时间序列时，Pandas 会将它们都转换为协调世界时 (UTC) 以进行统一处理，结果的时区也会是 UTC。
</details>

<hr>
<p><strong>14. 锚定偏置量构成的时间频率是均匀间隔的。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 锚定偏移量（如 `'M'` 月末，`'W-FRI'` 每周五）的间隔是不均匀的，因为每个月的天数不同，每周五之间的间隔也是固定的7天但日期会变。均匀间隔的频率是像 `'D'` (每日) 或 `'H'` (每小时) 这样的。
</details>

<hr>
<p><strong>15. <code>shift</code>函数可以推移时间戳，但不能推移数据。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `shift` 函数有两种用法：
  <ul>
    <li>`ts.shift(periods)`：<b>移动数据</b>，索引不变。</li>
    <li>`ts.shift(periods, freq)`：<b>移动索引</b>，数据不变。</li>
  </ul>
  因此，它既可以推移数据也可以推移时间戳。
</details>

<hr>
<p><strong>16. 当获得包含时间信息的时间戳时…可以将<code>normalize</code>设置为True。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `pd.to_datetime()` 的 `normalize=True` 参数或 `DatetimeIndex` 的 `.normalize()` 方法可以将时间戳的时间部分“抹掉”，设置为午夜 `00:00:00`。
</details>

<hr>
<p><strong>17. 不可以使用不包含在时间序列中的时间戳进行切片。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 时间序列的切片非常灵活。例如 `ts['2011-01-06':'2011-01-09']` 是完全有效的，即使 `'2011-01-06'` 和 `'2011-01-09'` 这两个日期本身并不在索引中，Pandas 也会返回这个日期范围内的所有数据。
</details>

<hr>
<p><strong>18. 将高频率的数据聚合到低频率成为向上采样，将低频率数据转换到高频率数据称为向下采样。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 描述正好相反。
  <ul>
    <li><b>向下采样 (Downsampling)</b>：将高频率数据聚合到低频率（例如，将每日数据聚合为每月数据）。</li>
    <li><b>向上采样 (Upsampling)</b>：将低频率数据转换到高频率（例如，将每月数据扩展为每日数据），这通常会引入缺失值。</li>
  </ul>
</details>

<hr>
<p><strong>19. 进行重新采样时，将<code>W-WED</code>转换到<code>W-FRI</code>属于向下采样（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `W-WED` (每周三) 和 `W-FRI` (每周五) 都是周度频率，它们的频率是相同的。这不属于向上或向下采样，只是一种频率的转换。
</details>

<hr>
<p><strong>20. 运行代码<code>pd.to_datetime([&#39;2000-1-1&#39;,&#39;31-12-2000&#39;,&#39;8-31-2000&#39;])</code>会报错（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `pd.to_datetime()` 的解析器非常强大，能够处理多种混合的日期格式。它能正确解析 `'31-12-2000'` (日-月-年) 和 `'8-31-2000'` (月-日-年)，不会报错。
</details>

<hr>
<p><strong>21. 当把<code>datetime</code>类型的数据作为索引时，数据类型变为<code>DatetimeIndex</code>。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当使用 `datetime` 对象列表或类似序列作为 Series/DataFrame 的索引时，Pandas 会自动将其转换为 `DatetimeIndex` 类型。
</details>

<hr>
<p><strong>22. <code>timedelta</code>可以查看<code>days</code>和<code>seconds</code>而不能查看<code>minutes</code>。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `timedelta` 对象内部只存储 `days`, `seconds`, `microseconds`。虽然没有直接的 `.minutes` 属性，但可以通过总秒数 `.total_seconds() / 60` 来计算分钟。
</details>

<hr>
<p><strong>23. <code>resample</code>函数得<code>loffset</code>参数可以用<code>shift</code>实现（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `loffset` (label offset) 用于对聚合后的标签进行调整，其效果与对结果调用 `.shift()` 方法类似。
</details>

<hr>
<p><strong>24. 向上采样中，目标频率是原频率得子区间（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 向上采样（如从月度到每日）意味着新的、更高频率的时间点是原始低频率区间的子集或细分。
</details>

<hr>
<p><strong>25. <code>date_range()</code>函数生产日期时间数据时，如果以6天为间隔可以设置参数<code>freq</code>为<code>‘6D’</code>。( )</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** Pandas 频率字符串支持在基础频率前加一个整数倍数，`'6D'` 是表示“6天”的正确写法。
</details>

<hr>
<p><strong>26. <code>...datetime.strptime(value, &#39;%Y/%m/%d&#39;)</code>都可以正确运行 ( )</strong></p>
<details>
  <summary style-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `strptime` 要求字符串 `value` 的格式必须与提供的 `format` 参数<b>严格匹配</b>。`'2011-01-03'` 与 `'%Y/%m/%d'` 的分隔符不匹配，会引发 `ValueError`。
</details>

<hr>
<p><strong>27. <code>datetime</code>的格式<code>%Y</code>显示的是四位的年份（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `%Y` 代表四位数的年份（如 2019），`%y` 代表两位数的年份（如 19）。
</details>

<hr>
<p><strong>28. <code>resample</code> 的方法参数中，<code>convention</code>的默认值为<code>‘start’</code>（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 在对 `Period` 数据进行重采样时，`convention` 参数用于决定将低频区间转换为高频区间时，是取区间的开始 (`'start'`) 还是结束 (`'end'`)。其默认值为 `'start'`。
</details>

<hr>
<p><strong>29. pandas的通用时间序列是不规则的，即时间序列的频率不是固定的 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** Pandas 的时间序列可以是不规则的，即时间戳之间没有固定的时间间隔。`resample` 等工具就是用来处理这种不规则序列并将其转换为规则频率的。
</details>

<h2 id="第十二章：一些Pandas中的高级用法"><a href="#第十二章：一些Pandas中的高级用法" class="headerlink" title="第十二章：一些Pandas中的高级用法"></a>第十二章：一些Pandas中的高级用法</h2><p><strong>1. 一个分类数组可以包含任一不可变的值类型（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 分类数据 (Categorical) 的类别 (`categories`) 可以是任何不可变类型，如字符串、整数、元组等。
</details>

<hr>
<p><strong>2. 分类数据一定是字符串。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 如上一题所述，分类数据的类别可以是任何不可变类型，不限于字符串。
</details>

<hr>
<p><strong>3. 将特定的大型数据集进行分析时，将数据转换为分类数据会大幅提高性能（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当一个列包含大量重复的字符串或其他对象时，将其转换为 `category` 类型会用整数编码替代原始值，从而大大减少内存占用，并能显著提升某些分析操作（如 `groupby`）的性能。
</details>

<hr>
<p><strong>4. 对于Series中的分类方法，<code>rename_categories</code>和<code>set_categories</code>…但前者不能改变类别的数量，而后者可以添加或删除类别（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是对这两个方法区别的准确描述。`rename_categories` 只是重命名现有的类别，数量不变。`set_categories` 则是用一个全新的列表来替换类别，可以增删类别。
</details>

<hr>
<p><strong>5. 对一个Categorical进行<code>set_categories</code>操作，赋值给一个新的对象，不会影响到新对象的类别。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `set_categories` 的作用就是<b>改变</b>或设置类别。将操作结果赋值给新对象，新对象的类别就是被设置成的新类别。
</details>

<hr>
<p><strong>6. <code>pipe</code>方法的一个潜在用途是将操作的序列泛化成可复用的函数（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `.pipe()` 方法允许将一个对象（如 DataFrame）作为第一个参数传递给一个函数，从而实现链式调用。这使得将一系列数据处理步骤封装成可复用的函数变得非常方便。
</details>

<hr>
<p><strong>7. <code>pandas.qcut</code>生成的结果的数据类型是<code>pandas.Categorical</code>（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `pd.qcut` 和 `pd.cut` 都用于数据分箱，它们返回的结果是一个 `Categorical` 对象。
</details>

<hr>
<p><strong>8. <code>df2=df.copy(),df2[&#39;k&#39;]=v</code>与<code>df2=df.assign(k=v)</code>是等价的（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 两者都实现了创建 `df` 的一个副本并添加或修改名为 `'k'` 的列。`.assign()` 方法专门为此设计，并返回一个新对象，而第一种方法是先显式复制再修改。在效果上是等价的。
</details>

<hr>
<p><strong>9. <code>...pd.unique(values)</code>返回的结果是<code>FALSE</code> （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `pd.unique()` 会返回输入序列中的<b>唯一值</b>，并保持其出现的<b>原始顺序</b>。对于 `values`，结果会是一个包含 `['apple', 'orange']` 的 NumPy 数组。
</details>

<hr>
<p><strong>10. <code>transform</code>可以产生一个标量值，并广播到各分组的尺寸数据中。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor:pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是对 `transform` 核心功能的准确描述。例如，`grouped.transform('mean')` 会计算每个分组的均值（一个标量），然后将这个标量值“广播”回该分组的所有原始位置。
</details>

<hr>
<p><strong>11. Categorical对象的<code>codes</code>属性对应的<code>dtype</code>为<code>float64</code>（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `.codes` 属性是一个 NumPy 数组，其元素是表示类别的<b>整数</b>编码，数据类型通常是 `int8` 或 `int16` 等整数类型，不是 `float64`。
</details>

<hr>
<p><strong>12. <code>transform</code>函数不可以改变它的输入（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `transform` 传入的函数必须返回一个与输入分组形状相同的对象，它用于“转换”数据，而不是像 `agg` 那样改变其形状（聚合）。
</details>

<hr>
<p><strong>13. 分类转换会自动指定类别的顺序。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当从序列创建 Categorical 对象时，如果没有明确指定类别，Pandas 会自动从数据中找出唯一值，并<b>按字母或数值顺序</b>排列它们作为类别。
</details>

<hr>
<p><strong>14. Categorical对象比Series使用更少的内存，在对象上进行操作也更快。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当数据包含大量重复值时，Categorical 对象通过整数编码来存储数据，可以显著减少内存占用，并提高某些操作（如 `groupby`）的性能。
</details>

<hr>
<p><strong>15. <code>resample</code>是一种基于时间分段的分组操作。 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `.resample()` 的核心功能就是根据指定的时间频率将时间序列数据划分到不同的时间“箱子”（分段）中，其行为类似于一个专门针对时间序列的 `groupby`。
</details>

<hr>
<p><strong>16. 使用<code>TimeGrouper</code>时，时间必须是Series或者DataFrame索引 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `TimeGrouper`（现在推荐使用 `pd.Grouper`）是 `groupby` 的一个特殊工具，它要求分组的轴必须是一个 `DatetimeIndex`。
</details>

<hr>
<p><strong>17. <code>DataFrame.assign</code>方法可以按指定修改原DataFrame（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `.assign()` 方法总是返回一个<b>新的</b> DataFrame 副本，其中包含了新增或修改的列，而<b>不修改</b>原始的 DataFrame。
</details>

<hr>
<p><strong>18. <code>...cat_s.remove_unused_categories()</code>可以去除所有没有出现在数据中的类别（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 这是 `.remove_unused_categories()` 方法的正确功能描述。
</details>

<hr>
<p><strong>19. <code>fruits_cat = df[&#39;fruit&#39;].astype(&#39;category&#39;)</code>得到的<code>fruits_cat</code>是一个Numpy数组。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `df['fruit'].astype('category')` 返回的是一个数据类型为 `category` 的 Pandas <b>Series</b> 对象，而不是 NumPy 数组。
</details>

<hr>
<p><strong>20. 通过<code>pandas.qcut</code>分箱函数生成的<code>Categories</code>对象的类别已经指定了顺序（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `qcut` 和 `cut` 生成的 `Categorical` 对象都是有序的（ordered），因为区间本身具有大小顺序。
</details>

<hr>
<p><strong>21. <code>take</code>函数得到的Series的索引是<code>values</code>的值。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `s.take(indices)` 会根据 `indices` 中的<b>位置</b>来从 `s` 中取值，但返回的新 Series 的索引是 `indices` <b>本身</b>的索引（如果 `indices` 是一个 Series）或者是一个新的整数索引。
</details>

<hr>
<p><strong>22. category的字符串类别输出时不带单引号。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 当打印一个分类类型的 Series 或 Categorical 对象时，其值（如果是字符串）通常不带引号，这是 Pandas 的一种显示优化。
</details>

<hr>
<p><strong>23. pandas的<code>TimeGrouper</code>可以使用<code>Grouper</code>替代（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** `pd.TimeGrouper` 在较新版本的 Pandas 中已被弃用，官方推荐使用 `pd.Grouper`，例如 `df.groupby(pd.Grouper(key='time', freq='5min'))`。
</details>

<hr>
<p><strong>24. <code>remove_categories</code>将移除类别所对应的值。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `.remove_categories()` 会移除指定的类别。如果被移除的类别在数据中存在，那么这些数据值会变成 `NaN`，而不是整个值（行）被移除。
</details>

<hr>
<p><strong>25. Categorical对象比Series使用更少的内存，在对象上进行操作也明显更快。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 此题与第 14 题相同，叙述正确。
</details>

<hr>
<p><strong>26. <code>g.transform(&#39;len&#39;)</code> 可以运行。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** `transform` 期望传入的函数能对每个分组（Series）进行计算并返回一个与输入形状相同的 Series。`len()` 函数作用于一个 Series 会返回一个<b>标量</b>（长度），而不是一个 Series。因此，`g.transform('len')`（或 `g.transform(len)`）会报错。能接受 `len` 的是 `.agg()` 或 `.apply()`。
</details>

<hr>
<p><strong>27. 对一个Categorical进行<code>set_categories</code>操作，赋值给一个新的对象，会影响到新对象的类别。（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 正确 (True)
  <br><br>
  **解析：** 此题与第 5 题的叙述相反。`set_categories` 的作用就是改变或设置类别，所以新对象的类别当然会是新设置的类别。
</details>

<hr>
<p><strong>28. <code>df[&#39;fruit&#39;].astype(&#39;category&#39;)</code>返回的是Numpy数组 （ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 此题与第 19 题相同，返回的是一个 Pandas <b>Series</b>。
</details>

<hr>
<p><strong>29. <code>Categories</code>对象的<code>categories</code>属性…<code>codes</code>属性…（ ）</strong></p>
<details>
  <summary style="font-weight: bold; cursor: pointer; color: #007bff;">点击查看解析</summary>
  <br>
  **正确答案：** 错误 (False)
  <br><br>
  **解析：** 描述正好相反。
  <ul>
    <li>`.categories`：是维度表，包含唯一的类别<b>值</b>。</li>
    <li>`.codes`：是引用维度表的<b>整数数组</b>。</li>
  </ul>
</details></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://cccignore.github.io">Yinuo Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://cccignore.github.io/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A4%E6%96%AD%E9%A2%98%E6%95%B4%E7%90%86/">https://cccignore.github.io/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A4%E6%96%AD%E9%A2%98%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://cccignore.github.io" target="_blank">CYN's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/">考试复习</a></div><div class="post-share"><div class="social-share" data-image="https://www.huizhanii.com/wp-content/uploads/2023/10/202310040719411.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86/" title="Python数据分析选择题整理"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://www.huizhanii.com/wp-content/uploads/2023/10/202310040719411.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python数据分析选择题整理</div></div><div class="info-2"><div class="info-item-1">   第二章：Python语言基础与环境 + 第三章：Pandas 数据结构与操作1. 执行后可以查看Python的版本的是 （ ）A. import sys; print(sys.version)B. import system; print(system.version)C. import system; print(system.Version)D. import sys; print(sys.Version)    点击查看解析与代码    解析：   要查看 Python 的版本，正确的模块是 `sys`，而不是 `system`。`sys` 模块提供了与 Python 解释器及其环境相关的功能。   `sys.version` 是一个字符串，包含了 Python 解释器的版本号、编译日期和编译器信息。   因此，正确的选项是 A。    正确答案： A   代码示例：  12345import sysprint(sys.version)# 示例输出可能类似于：# 3.9.7 (default, Oct 16 2021, 19:42:19)# [Clang 13.0.0...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86/" title="Python数据分析选择题整理"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://www.huizhanii.com/wp-content/uploads/2023/10/202310040719411.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-20</div><div class="info-item-2">Python数据分析选择题整理</div></div><div class="info-2"><div class="info-item-1">   第二章：Python语言基础与环境 + 第三章：Pandas 数据结构与操作1. 执行后可以查看Python的版本的是 （ ）A. import sys; print(sys.version)B. import system; print(system.version)C. import system; print(system.Version)D. import sys; print(sys.Version)    点击查看解析与代码    解析：   要查看 Python 的版本，正确的模块是 `sys`，而不是 `system`。`sys` 模块提供了与 Python 解释器及其环境相关的功能。   `sys.version` 是一个字符串，包含了 Python 解释器的版本号、编译日期和编译器信息。   因此，正确的选项是 A。    正确答案： A   代码示例：  12345import sysprint(sys.version)# 示例输出可能类似于：# 3.9.7 (default, Oct 16 2021, 19:42:19)# [Clang 13.0.0...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/my-avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yinuo Chen</div><div class="author-info-description">一个热爱技术与生活的探索者</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cccignore"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://www.instagram.com/cyn07111/" target="_blank" title="Instagram"><i class="fab fa-instagram" style="color: #E4405F;"></i></a><a class="social-icon" href="https://space.bilibili.com/284576123" target="_blank" title="哔哩哔哩"><i class="fab fa-bilibili" style="color: #FF8EB3;"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=4930687131" target="_blank" title="网易云音乐"><i class="fas fa-music" style="color: #dd001b;"></i></a><a class="social-icon" href="https://weibo.com/u/5789743402" target="_blank" title="微博"><i class="fab fa-weibo" style="color: #E6162D;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到CYN's Blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9APython%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%8E%AF%E5%A2%83-%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9APandas-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">第二章：Python语言基础与环境 + 第三章：Pandas 数据结构与操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9ANumPy-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">第四章：NumPy 数组与操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9APandas-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">3.</span> <span class="toc-text">第五章：Pandas 核心功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.</span> <span class="toc-text">第六章：数据输入输出与接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text">第七章：数据清洗与转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%90%88%E5%B9%B6%E4%B8%8E%E9%87%8D%E5%A1%91"><span class="toc-number">6.</span> <span class="toc-text">第八章：数据合并与重塑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">第九章：数据可视化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">8.</span> <span class="toc-text">第十章：高级数据分析技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E5%92%8C%E5%88%86%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">第十一章：时间序列数据的处理和分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E4%B8%80%E4%BA%9BPandas%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">第十二章：一些Pandas中的高级用法</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A4%E6%96%AD%E9%A2%98%E6%95%B4%E7%90%86/" title="Python数据分析判断题整理"><img src= "/img/loading.gif" data-lazy-src="https://www.huizhanii.com/wp-content/uploads/2023/10/202310040719411.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python数据分析判断题整理"/></a><div class="content"><a class="title" href="/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A4%E6%96%AD%E9%A2%98%E6%95%B4%E7%90%86/" title="Python数据分析判断题整理">Python数据分析判断题整理</a><time datetime="2025-06-20T15:43:27.000Z" title="发表于 2025-06-20 23:43:27">2025-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86/" title="Python数据分析选择题整理"><img src= "/img/loading.gif" data-lazy-src="https://www.huizhanii.com/wp-content/uploads/2023/10/202310040719411.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python数据分析选择题整理"/></a><div class="content"><a class="title" href="/2025/06/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86/" title="Python数据分析选择题整理">Python数据分析选择题整理</a><time datetime="2025-06-20T04:04:41.000Z" title="发表于 2025-06-20 12:04:41">2025-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/18/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%A2%AF%E5%AD%90-%E8%B5%94%E9%92%B1%E6%9C%BA%E5%9C%BA/" title="低成本梯子-赔钱机场"><img src= "/img/loading.gif" data-lazy-src="https://www.notebookcheck.net/fileadmin/Notebooks/News/_nc3/vpn_safety.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="低成本梯子-赔钱机场"/></a><div class="content"><a class="title" href="/2025/06/18/%E4%BD%8E%E6%88%90%E6%9C%AC%E6%A2%AF%E5%AD%90-%E8%B5%94%E9%92%B1%E6%9C%BA%E5%9C%BA/" title="低成本梯子-赔钱机场">低成本梯子-赔钱机场</a><time datetime="2025-06-17T17:24:26.000Z" title="发表于 2025-06-18 01:24:26">2025-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/17/%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%EF%BC%9A%E6%89%93%E9%80%A0%E4%B8%80%E7%AF%87%E5%8A%9F%E8%83%BD%E4%B8%B0%E5%AF%8C%E3%80%81%E6%8E%92%E7%89%88%E4%BC%98%E9%9B%85%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" title="从零到一：打造一篇功能丰富、排版优雅的现代化博客文章"><img src= "/img/loading.gif" data-lazy-src="https://images.unsplash.com/photo-1517694712202-14dd9538aa97?q=80&amp;w=2070&amp;auto=format&amp;fit=crop" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从零到一：打造一篇功能丰富、排版优雅的现代化博客文章"/></a><div class="content"><a class="title" href="/2025/06/17/%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%EF%BC%9A%E6%89%93%E9%80%A0%E4%B8%80%E7%AF%87%E5%8A%9F%E8%83%BD%E4%B8%B0%E5%AF%8C%E3%80%81%E6%8E%92%E7%89%88%E4%BC%98%E9%9B%85%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" title="从零到一：打造一篇功能丰富、排版优雅的现代化博客文章">从零到一：打造一篇功能丰富、排版优雅的现代化博客文章</a><time datetime="2025-06-17T15:36:00.000Z" title="发表于 2025-06-17 23:36:00">2025-06-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/16/hello-world/" title="Hello World">Hello World</a><time datetime="2025-06-16T13:44:38.000Z" title="发表于 2025-06-16 21:44:38">2025-06-16</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Yinuo Chen</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"lang":"zh-CN","locale":{"placeholder":"欢迎留言讨论~ 支持 Markdown 语法"},"emoji":["https://unpkg.com/@waline/emojis@1.2.0/weibo","https://unpkg.com/@waline/emojis@1.2.0/alus","https://unpkg.com/@waline/emojis@1.2.0/bilibili"],"meta":["nick","mail","link"],"requiredMeta":["nick","mail"],"wordLimit":[1,1000],"pageSize":10,"copyright":false,"dark":"html[data-theme=\"dark\"]"}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://blog-waline-azure-pi.vercel.app',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/sakuraPlus.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>